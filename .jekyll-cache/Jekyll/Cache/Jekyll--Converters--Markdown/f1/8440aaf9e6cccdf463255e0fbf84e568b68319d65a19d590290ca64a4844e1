I"<h1 id="linked-list">Linked List</h1>

<p>Linked List는 value와 node가 한 세트이며 node는 다음 순서의 value를 가리킨다.</p>

<!--more-->

<h2 id="linked-list-vs-arrays">Linked List vs Arrays</h2>

<p>검색시 똑같은 O(n)의 시간 복잡도를 갖지만 Linked List는 random하게 메모리에 저장하고 Array는 데이터 바로 옆에 순서대로 저장하기 때문에</p>

<p>같은 시간복잡도를 갖더라도 Array가 검색에 더 빠르다.</p>

<h1 id="methods">Methods</h1>

<table>
  <thead>
    <tr>
      <th>methods</th>
      <th>Big O notation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Prepend</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>Append</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>Lookup</td>
      <td>O(n)</td>
    </tr>
    <tr>
      <td>insert</td>
      <td>O(n)</td>
    </tr>
    <tr>
      <td>delete</td>
      <td>O(n)</td>
    </tr>
  </tbody>
</table>

<p>Prepend와 Append는 head와 tail에 추가하는 것으로 list에 들어가지 않아도 바로 실행 가능하기 때문에 O(1)이다.</p>

<p>나머지 모든 행동은 순서를 따라가서 해당 value에 도착해 동작해야해서 O(n)이다.</p>

<h1 id="pointer">Pointer</h1>

<p>Linked list에는 다른 데이터 구조에는 없는 개념인 Pointer가 있다. 하나의 node가 다른 node를 가르키는 것의 연속이기 때문이다.</p>

<p>pointer는 간단하게 특정 데이터가 있는 곳을 가리키는 reference를 말한다.</p>

<p>우리가 선언하는 객체의 이름도 일종의 pointer로서 해당 객체의 주소값을 담고 있는 것이다. 해당 객체의 주소값을 없애버리면 참조받지 않는 객체 데이터는 garbage collector에 의해 지워진다.</p>

<p>C언어에선 garbage collector의 기능을 사람이 해줘야한다. 이는 잘 다루면 컴퓨터의 효율면에서 성능을 크게 향상 시킬 수 있다.</p>
:ET