---
layout: post
title: Make Inheritance in JS
tags: [JavaScript, AJAX, Theories]
excerpt_separator: <!--more-->
---

# Asynchronous

하나의 코드의 흐름과는 별개의 코드의 흐름을 만들어 여러가지 작업을 동시에 할 수 있게 하는 것.

좋은 service를 위해선 필수적이다.

<!--more-->

# AJAX

Asynchronous Javascript And Xml의 약자

Allows us to communicate with remote web server in an asynchronous way. with AJAX calls, we can request data from web service dynamically.

# API?

Application Programming Interface

Piece of software that can be used by another piece of software, in order to allow applications to talk to each other

# Promises

Definition : An object that is used as a placeholder for the future result of an asynchronous operation (A container for an asynchronously delivered value, A container for a future value)

여기서 future value = Response from AJAX call 라고 생각하면 된다.

Callback function 들이 겹겹히 쌓여 Callback Hell이 되는것을 해결해주는 ES6에서 추가된 기능이다.

## Callback Hell?

```javascript
//"Callback Hell"
//cascade하게 function이 한번에 모두 실행되어야 할 때 이렇게 설계한다.
function f1(){
    function f2(){
        function f3(){

        }
    }
}
```

## Promise의 장점

We no longer need to rely on events and callbacks passed into asynchronous functions to handle asynchronous results

Instead of nesting callbacks, we can chain promises for a sequence of asynchronous operations: escaping callback hell

## Promise Lifecycle

Promises is only settled once! (Fullfilled or Rejected)

![PromiseLifeCycle]({{ "/assets/img/aboutJavaScript/PromisesLifeCycle.png" | relative_url }})

## Let's Implement Promises

Callback Chain보다 직관적이고 읽기 쉽다.

```javascript
//하나의 promise가 끝나고 다른 promise를 실행
//따라서 aka. "flat chain"
const getCountryData = function (country) {
    //country 1
    fetch('https://restcountries.eu/rest/v2/name/${country}')
        .then(response => response.json())
        .then(data => {
            renderCounrty(data[0]);
            const neighbour = data[0].borders[0];

            if (!neighbour) return;

            //country 2
            return fetch('https://restcountries.eu/rest/v2/name/${neighbour}');

            // 안좋은 예 Promise안에 Promise가 되므로 callback hell에 해당한다.
            //fetch('https://restcountries.eu/rest/v2/name/${neighbour}').then(response => response.json())
        })
        .then(response => response.json());
        .then(data => renderCountry(data, 'neighbour'));
}

getCounrtyData('portugal');
```

# Handle Rejected Promises (Handle Errors)

1. then method의 2번째 parameter에 error handle callback function implement
2. catch function을 chain 안에 추가한다. promise가 rejected이면 어디서 error가 발생하든 발동하는 것이 특징

java의 try...catch...finally와 유사하다.

```javascript
const getCountryData = function (country) {
    //country 1
    fetch('https://restcountries.eu/rest/v2/name/${country}')

        
        .then(response => {
            console.log(response);

            //How to Throw Error Manually no.1
            if(!response.ok)
                //Throw시에 현재 method가 바로 종료하고 Rejected promise를 return = catch method 발동
                throw new Error('Country not found ${response.status}');

            return response.json()}, 
        //How to catch Err no.1
        //then method에 두번째 parameter추가하기
        err => alert(err))
        .then(data => {
            renderCounrty(data[0]);
            const neighbour = data[0].borders[0];

            if (!neighbour) return;

            //country 2
            //chaining promise
            return fetch('https://restcountries.eu/rest/v2/name/${neighbour}');
        })
        .then(response => response.json());
        .then(data => renderCountry(data, 'neighbour'));

        //How to catch Err no.2
        //err에는 JS built-in error object가 들어온다.
        .catch(err => {
            console.error('${err} !!!!!!!');
            alert('${err.message}');
        });

        //Promise가 fullfilled이건 reject이건 반드시 발동하는 method
        .finally(() => {
            
        })
}

getCounrtyData('portugal');
```
# How Asyncronous works behind the scene???

Runtime? : 자바스크립트 코드를 실행하기 위한 모든 부품들의 모임 즉, 실행환경

![JSRuntimeInBrowser]({{ "/assets/img/aboutJavaScript/JSRuntimeInBrowser.png" | relative_url }})

JS engine = Heap + Call stack

Heap : Where Objects are stored in memory

Call stack : Where code is actually executed, Only ONE!!!! thread of execution. NO Multitasking!!

Web APIs : APIs provided to the engine, JS의 파트가 아니다. (DOM, Fetch API, Timers, Geolocation API 등등...)

Callback Queue : Ready-to-be-executed callback functions(coming from events)

Event Loop : When 'Call stack' is empty, event loop takes callbacks from the callback queue and puts them into call stack so that they can be executed, Asyncronous하게 움직이도록 하는데에 핵심이다.

## JS엔진은 Single Thread인데 어떻게 Asyncronous하게 움직일 수 있지?



