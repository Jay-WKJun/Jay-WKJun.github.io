---
layout: post
title: Make Inheritance in JS
tags: [JavaScript, AJAX, Theories]
excerpt_separator: <!--more-->
---

# Asynchronous

하나의 코드의 흐름과는 별개의 코드의 흐름을 만들어 여러가지 작업을 동시에 할 수 있게 하는 것.

좋은 service를 위해선 필수적이다.

<!--more-->

# AJAX

Asynchronous Javascript And Xml의 약자

Allows us to communicate with remote web server in an asynchronous way. with AJAX calls, we can request data from web service dynamically.

# API?

Application Programming Interface

Piece of software that can be used by another piece of software, in order to allow applications to talk to each other

# Promises

Definition : An object that is used as a placeholder for the future result of an asynchronous operation (A container for an asynchronously delivered value, A container for a future value)

여기서 future value = Response from AJAX call 라고 생각하면 된다.

Callback function 들이 겹겹히 쌓여 Callback Hell이 되는것을 해결해주는 ES6에서 추가된 기능이다.

## Callback Hell?

```javascript
//"Callback Hell"
//cascade하게 function이 한번에 모두 실행되어야 할 때 이렇게 설계한다.
function f1(){
    function f2(){
        function f3(){

        }
    }
}
```

## Promise의 장점

We no longer need to rely on events and callbacks passed into asynchronous functions to handle asynchronous results

Instead of nesting callbacks, we can chain promises for a sequence of asynchronous operations: escaping callback hell

## Promise Lifecycle

Promises is only settled once! (Fullfilled or Rejected)

![PromiseLifeCycle]({{ "/assets/img/aboutJavaScript/PromisesLifeCycle.png" | relative_url }})

## Let's Implement Promises

Callback Chain보다 직관적이고 읽기 쉽다.

```javascript
//하나의 promise가 끝나고 다른 promise를 실행
//따라서 aka. "flat chain"
const getCountryData = function (country) {
    //country 1
    fetch('https://restcountries.eu/rest/v2/name/${country}')
        .then(response => response.json())
        .then(data => {
            renderCounrty(data[0]);
            const neighbour = data[0].borders[0];

            if (!neighbour) return;

            //country 2
            return fetch('https://restcountries.eu/rest/v2/name/${neighbour}');

            // 안좋은 예 Promise안에 Promise가 되므로 callback hell에 해당한다.
            //fetch('https://restcountries.eu/rest/v2/name/${neighbour}').then(response => response.json())
        })
        .then(response => response.json());
        .then(data => renderCountry(data, 'neighbour'));
}

getCounrtyData('portugal');
```

# Handle Rejected Promises (Handle Errors)

1. then method의 2번째 parameter에 error handle callback function implement
2. catch function을 chain 안에 추가한다. promise가 rejected이면 어디서 error가 발생하든 발동하는 것이 특징

java의 try...catch...finally와 유사하다.

```javascript
const getCountryData = function (country) {
    //country 1
    fetch('https://restcountries.eu/rest/v2/name/${country}')

        
        .then(response => {
            console.log(response);

            //How to Throw Error Manually no.1
            if(!response.ok)
                //Throw시에 현재 method가 바로 종료하고 Rejected promise를 return = catch method 발동
                throw new Error('Country not found ${response.status}');

            return response.json()}, 
        //How to catch Err no.1
        //then method에 두번째 parameter추가하기
        err => alert(err))
        .then(data => {
            renderCounrty(data[0]);
            const neighbour = data[0].borders[0];

            if (!neighbour) return;

            //country 2
            //chaining promise
            return fetch('https://restcountries.eu/rest/v2/name/${neighbour}');
        })
        .then(response => response.json());
        .then(data => renderCountry(data, 'neighbour'));

        //How to catch Err no.2
        //err에는 JS built-in error object가 들어온다.
        .catch(err => {
            console.error('${err} !!!!!!!');
            alert('${err.message}');
        });

        //Promise가 fullfilled이건 reject이건 반드시 발동하는 method
        .finally(() => {
            
        })
}

getCounrtyData('portugal');
```
# How Asyncronous works behind the scene???

Runtime? : 자바스크립트 코드를 실행하기 위한 모든 부품들의 모임 즉, 실행환경

![JSRuntimeInBrowser]({{ "/assets/img/aboutJavaScript/JSRuntimeInBrowser.png" | relative_url }})

JS engine = Heap + Call stack

Heap : Where Objects are stored in memory

Call stack : Where code is actually executed, Only ONE!!!! thread of execution. NO Multitasking!!

Web APIs : APIs provided to the engine, JS의 파트가 아니다. (DOM, Fetch API, Timers, Geolocation API 등등...)

Callback Queue : Ready-to-be-executed callback functions(coming from events)

Event Loop : When 'Call stack' is empty, event loop takes callbacks from the callback queue and puts them into call stack so that they can be executed, Asyncronous하게 움직이도록 하는데에 핵심이다.

## JS엔진은 Single Thread인데 어떻게 Asyncronous하게 움직일 수 있지?

web API, callback queue(or microtasks queue), event loop가 Async를 가능하게 해준다.

call stack 이외에 Fetch(), setTimeOut(), DOM() 등을 제공하는 webAPIs에서 개별적으로 처리가 진행이 된다. (DOM은 Async하게 움직이지 않고 바로 callback queue에 추가된다.)

만약 image load처리가 있다고 가정한다면, image load가 끝나면 load event가 발동되고 이를 통해 callback queue에 추가 된다.

callback queue에서 순서를 기다리고 call stack에 실행되고 있는 코드가 없다면

Event Loop를 통해 image load 이벤트가 callback queue에서 call stack으로 올라가 실행된다.(aka. "Event Loop tick")

즉, Event loop가 어떤 코드를 실행시킬지 정하기 때문에 Async환경을 만드는데 가장 중요하다.

- promise

promise는 일반 event와는 조금 다르다.

promise들은 callback queue가 아닌 microtasks queue를 사용하며 callback queue보다 우선 실행된다.

```javascript
//1
console.log('Test start');
//2
setTimeout(() => console.log('0 sec timer'), 0);
//3
//Promise를 만들어 즉시 resolve한다.
Promise.resolve('Resolved promise 1').then(res => console.log(res)); //expecting result : "Resolved promise 1"

//4
Promise.resolve('Resolved promise 2').then(res => {
    for (let i = 0; i < 10000000000; i++) {}
    console.log(res);
}); //expecting result : "Resolved promise 1"
//5
console.log('Test end');

//출력 순서 1 -> 4 -> 3 -> 2
//call back이외의 code들이 가장 먼저 실행된다. Synchronous한 1,5가 가장 먼저 실행된다.
//promise는 microtasks queue로 인해 가장 먼저 실행된다. 따라서 3,4
//callback queue에 해당하는 2는 가장 마지막
```

# Promise

JS의 특별한 Object인 Promise에 대해

## constructor

promise의 constructor는 오직 하나의 argument만 받는다

aka. "executor function"