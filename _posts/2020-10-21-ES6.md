---
layout: post
title: Javascript ES6
tags: [JavaScript, ES6]
excerpt_separator: <!--more-->
---

# ES6

ECMAScript 6 이라는 의미로 javascript의 버전이라고 생각하면 간단하다.

특히 ES6는 전 버전에 비해 굉장이 많은 update가 있었기 때문에 주목할만 하다.

<!--more-->

## 추가된 사항들 개요

- Variable Declarations with 'let' and 'const'
- Blocks and IIFEs
- Strings
- Arrow Functinos
- Destructuring
- Arrays
- The Spread Operator
- Rest and Default Paramaters
- Maps
- Classes and subclasses

# let and const

2가지의 새로운 variable 선언 방법이 생겼다. let은 variable, const는 constant로 정의되는 순간 바꿀 수 없다.(바꾸면 에러)

'var'는 function scoped이지만 'let'과 'const'는 block scoped이다.

```javascript
// ES5
function driversLicence5(passedTest) {
    
    if (passedTest) {
        
        //1. var는 execution context를 만들때 hoisting되어 undefined로 먼저 정의 된다.
        console.log(firstName);     //undefined
        var firstName = 'John';
        var yearOfBirth = 1990;
    }
    
    //2. 위 if block안에서 var를 선언 및 정의해도 function scoped이기 때문에
    //block바깥에서도 변수의 사용이 가능하다
    console.log(firstName + ', born in ' + yearOfBirth + ', is now officially allowed to drive a car.');
}

driversLicence5(true);


// ES6
function driversLicence6(passedTest) {
    
    //1. var와 달리 let은 hoisting될 때 정의 되지 않으므로
    //선언과 정의까지 해주어야 사용이 가능하다.
    //console.log(firstName);       //error
    let firstName;
    const yearOfBirth = 1990;
    
    if (passedTest) {
        firstName = 'John';
    }
    
    //2. if block안에 let이 선언되면 if block이 끝남과 동시에 let으로 선언된 변수들은 사라지기 때문에 이곳에선 사용이 불가하다.
    //그러나 let을 바깥에 선언하고 if block안에서 정의하면 if block바깥에 let변수가 존재하게 되므로 사용이 가능하다
    console.log(firstName + ', born in ' + yearOfBirth + ', is now officially allowed to drive a car.');
}

driversLicence6(true);



var i = 23;

for (var i = 0; i < 5; i++) {
    console.log(i);
}

console.log(i);     //let일 경우 '23'출력
                    //for의 i와 바깥의 i는 별개의 변수 취급(for문이 끝나면 안에 있는 let i는 사라지기 때문)
                    
                    //var일 경우 '5'출력
                    //for의 i와 같은 변수 취급이기 때문에 바깥의 i가 갱신된다.
```

# Blocks and IIFEs

block scoped인 let과 const로 블록을 이용해 ES5의 (function(){})();처럼 IIFE를 만드는 것이 가능하다

```javascript
// ES6
{
    const a = 1;
    let b = 2;
    var c = 3;
}

//console.log(a + b);   //error
console.log(c);


// ES5
(function() {
    var c = 3;
})();

//console.log(c);       //error
```

# Strings in ES6

ES5보다 더 쉽게 string을 다룰 수 있게 되었다.

```javascript

let firstName = 'John';
let lastName = 'Smith';
const yearOfBirth = 1990;

function calcAge(year) {
    return 2016 - year;
}

// ES5
console.log('This is ' + firstName + ' ' + lastName + '. He was born in ' + yearOfBirth + '. Today, he is ' + calcAge(yearOfBirth) + ' years old.');

// ES6
console.log(`This is ${firstName} ${lastName}. He was born in ${yearOfBirth}. Today, he is ${calcAge(yearOfBirth)} years old.`);


const n = `${firstName} ${lastName}`;
console.log(n.startsWith('j'));     //대소문자구분
console.log(n.endsWith('Sm'));
console.log(n.includes('oh'));
console.log(`${firstName} `.repeat(5));

```

# Arrow Functions

anonymous function을 간단하게 표현할 수 있는 기능이다.

```javascript
const years = [1990, 1965, 1982, 1937];

// ES5
var ages5 = years.map(function(el) {
    return 2016 - el;
});
console.log(ages5);


// ES6
let ages6 = years.map(el => 2016 - el);
console.log(ages6);

//argument가 여러개인 경우 ()필요
ages6 = years.map((el, index) => `Age element ${index + 1}: ${2016 - el}.`);
console.log(ages6);

//안의 코드가 여러줄인 경우 {}필요
ages6 = years.map((el, index) => {
    const now = new Date().getFullYear();
    const age = now - el;
    return `Age element ${index + 1}: ${age}.`
});
console.log(ages6);
```

## Arrow function의 this

The arrow Function shares the lexical 'this' keyword of its surroundings.

```javascript
// ES5
var box5 = {
    color: 'green',
    position: 1,
    clickMe: function() {
       
       /* 
        function안에 function은 regular function이므로 그 안의 this는
        window object를 가리킨다.
       */
       var self = this; 
       document.querySelector('.green').addEventListener('click', function() {
            var str = 'This is box number ' + self.position + ' and it is ' + self.color;
            alert(str);
        });
    }
}
box5.clickMe();


// ES6
const box6 = {
    color: 'green',
    position: 1,
    clickMe: function() {
        // arrow function의 this는 부모 function의 this를 공유한다.
        //따라서 this는 box6 object를 가리킨다.
        document.querySelector('.green').addEventListener('click', () => {
            var str = 'This is box number ' + this.position + ' and it is ' + this.color;
            alert(str);
        });
    }
}
box6.clickMe();


const box66 = {
    color: 'green',
    position: 1,
    // arrow function의 this는 부모 function의 this를 공유한다.
    //따라서 this는 box66 object가 아닌 window object를 가리킨다.
    clickMe: () => {
        document.querySelector('.green').addEventListener('click', () => {
            var str = 'This is box number ' + this.position + ' and it is ' + this.color;
            alert(str);     //undefined
        });
    }
}
box66.clickMe();

//////////////////////////////////////////////////////

function Person(name) {
    this.name = name;
}

// ES5
Person.prototype.myFriends5 = function(friends) {
    
    var arr = friends.map(function(el) {
        //function안에 function = regular function, this는 window object를 가리킴
        //bind가 없을 경우, this.name = ""
        //bind로 Person 객체를 묶어줬을 경우, this.name = 'bob', 'jane', 'mark'
       return this.name + ' is friends with ' + el; 
    }.bind(this));
    //bind의 this는 Person object를 가리키고 해당 객체를 copy한다.
    
    console.log(arr);
}

var friends = ['Bob', 'Jane', 'Mark'];
new Person('John').myFriends5(friends);


// ES6
Person.prototype.myFriends6 = function(friends) {

    //this는 Person object를 가리킨다.
    var arr = friends.map(el => `${this.name} is friends with ${el}`);

    console.log(arr);
}

new Person('Mike').myFriends6(friends);
```

# Destructuring

여러 데이터가 묶여있는 객체에서 각 데이터를 하나씩 빼와 변수에 한번에 저장할 수 있도록 하는 기능

```javascript
// ES5
var john = ['John', 26];
//var name = john[0];
//var age = john[1];

// ES6
//각각 name과 age에 저장된다.
const [name, age] = ['John', 26];
console.log(name);      //'John'
console.log(age);       //26

const obj = {
    firstName: 'John',
    lastName: 'Smith'
};

//주의할 점 : 객체의 키값과 {}안의 이름이 동일해아한다.
const {firstName, lastName} = obj;
console.log(firstName);
console.log(lastName);

//변수값을 바꿔서 꺼내고 싶다면 다음과같이 하면 된다.
const {firstName: a, lastName: b} = obj;
console.log(a);
console.log(b);


function calcAgeRetirement(year) {
    const age = new Date().getFullYear() - year;
    //여러 변수를 한번에 return하고 싶다면 다음과 같이 하면 된다.(여러개의 데이터를 return하고 싶을 때 굳이 객체를 return하지 않아도 된다.)
    return [age, 65 - age];
}

//array형태로 return했으므로 array형태로 destructuring하면 된다.
const [age2, retirement] = calcAgeRetirement(1990);
console.log(age2);
console.log(retirement);
```

# Arrays in ES6

Array에 많은 기능들이 추가 되었다.

```javascript
const boxes = document.querySelectorAll('.box');

/*
    class 이름 중에 box가 들어온걸 모두 가져오면 boxes에는 array가 아닌
    각 class의 DOM이 node list로 존재하기 때문에 Array로 변환시켜 줄 필요가 있다.
*/

//ES5
var boxesArr5 = Array.prototype.slice.call(boxes);
boxesArr5.forEach(function(cur) {
    cur.style.backgroundColor = 'dodgerblue';
});

//ES6
const boxesArr6 = Array.from(boxes);
//이렇게 한줄로 표현 할 수도 있다.
Array.from(boxes).forEach(cur => cur.style.backgroundColor = 'dodgerblue');

///////////////////////////////////////////

//Loops
//ES5
for(var i = 0; i < boxesArr5.length; i++) {
    
    if(boxesArr5[i].className === 'box blue') {
        continue;
    }
    
    boxesArr5[i].textContent = 'I changed to blue!';
    
}

//ES6
//aka.'for of'
for (const cur of boxesArr6) {
    if (cur.className.includes('blue')) {
        continue;
    }
    cur.textContent = 'I changed to blue!';
}

///////////////////////////////////////////


//ES5
var ages = [12, 17, 8, 21, 14, 11];

var full = ages.map(function(cur) {
    return cur >= 18;
});
console.log(full);                      //[false, false, false, ture, false, false]

console.log(full.indexOf(true));        //3
console.log(ages[full.indexOf(true)]);  //21


//ES6
//findIndex에 넣어준 callback function이 true를 반환할 때의 index를 반환한다.
console.log(ages.findIndex(cur => cur >= 18));  //3
//findIndex에 넣어준 callback function이 true를 반환할 때의 값을 반환한다.(index를 따로 찾을 필요가 없다.)
console.log(ages.find(cur => cur >= 18));       //21
```

# Spread Operator

