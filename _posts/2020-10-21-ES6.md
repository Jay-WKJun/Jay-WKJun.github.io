---
layout: post
title: Javascript ES6
tags: [JavaScript, ES6]
excerpt_separator: <!--more-->
---

# ES6

ECMAScript 6 이라는 의미로 javascript의 버전이라고 생각하면 간단하다.

특히 ES6는 전 버전에 비해 굉장이 많은 update가 있었기 때문에 주목할만 하다.

<!--more-->

## 추가된 사항들 개요

- Variable Declarations with 'let' and 'const'
- Blocks and IIFEs
- Strings
- Arrow Functinos
- Destructuring
- Arrays
- The Spread Operator
- Rest and Default Paramaters
- Maps
- Classes and subclasses

# let and const

2가지의 새로운 variable 선언 방법이 생겼다. let은 variable, const는 constant로 정의되는 순간 바꿀 수 없다.(바꾸면 에러)

'var'는 function scoped이지만 'let'과 'const'는 block scoped이다.

```javascript
// ES5
function driversLicence5(passedTest) {
    
    if (passedTest) {
        
        //1. var는 execution context를 만들때 hoisting되어 undefined로 먼저 정의 된다.
        console.log(firstName);     //undefined
        var firstName = 'John';
        var yearOfBirth = 1990;
    }
    
    //2. 위 if block안에서 var를 선언 및 정의해도 function scoped이기 때문에
    //block바깥에서도 변수의 사용이 가능하다
    console.log(firstName + ', born in ' + yearOfBirth + ', is now officially allowed to drive a car.');
}

driversLicence5(true);


// ES6
function driversLicence6(passedTest) {
    
    //1. var와 달리 let은 hoisting될 때 정의 되지 않으므로
    //선언과 정의까지 해주어야 사용이 가능하다.
    //console.log(firstName);       //error
    let firstName;
    const yearOfBirth = 1990;
    
    if (passedTest) {
        firstName = 'John';
    }
    
    //2. if block안에 let이 선언되면 if block이 끝남과 동시에 let으로 선언된 변수들은 사라지기 때문에 이곳에선 사용이 불가하다.
    //그러나 let을 바깥에 선언하고 if block안에서 정의하면 if block바깥에 let변수가 존재하게 되므로 사용이 가능하다
    console.log(firstName + ', born in ' + yearOfBirth + ', is now officially allowed to drive a car.');
}

driversLicence6(true);



var i = 23;

for (var i = 0; i < 5; i++) {
    console.log(i);
}

console.log(i);     //let일 경우 '23'출력
                    //for의 i와 바깥의 i는 별개의 변수 취급(for문이 끝나면 안에 있는 let i는 사라지기 때문)
                    
                    //var일 경우 '5'출력
                    //for의 i와 같은 변수 취급이기 때문에 바깥의 i가 갱신된다.
```

# Blocks and IIFEs

block scoped인 let과 const로 블록을 이용해 ES5의 (function(){})();처럼 IIFE를 만드는 것이 가능하다

```javascript
// ES6
{
    const a = 1;
    let b = 2;
    var c = 3;
}

//console.log(a + b);   //error
console.log(c);


// ES5
(function() {
    var c = 3;
})();

//console.log(c);       //error
```

# Strings in ES6

ES5보다 더 쉽게 string을 다룰 수 있게 되었다.

```javascript

let firstName = 'John';
let lastName = 'Smith';
const yearOfBirth = 1990;

function calcAge(year) {
    return 2016 - year;
}

// ES5
console.log('This is ' + firstName + ' ' + lastName + '. He was born in ' + yearOfBirth + '. Today, he is ' + calcAge(yearOfBirth) + ' years old.');

// ES6
console.log(`This is ${firstName} ${lastName}. He was born in ${yearOfBirth}. Today, he is ${calcAge(yearOfBirth)} years old.`);


const n = `${firstName} ${lastName}`;
console.log(n.startsWith('j'));     //대소문자구분
console.log(n.endsWith('Sm'));
console.log(n.includes('oh'));
console.log(`${firstName} `.repeat(5));

```

# Arrow Functions

anonymous function을 간단하게 표현할 수 있는 기능이다.

```javascript
const years = [1990, 1965, 1982, 1937];

// ES5
var ages5 = years.map(function(el) {
    return 2016 - el;
});
console.log(ages5);


// ES6
let ages6 = years.map(el => 2016 - el);
console.log(ages6);

//argument가 여러개인 경우 ()필요
ages6 = years.map((el, index) => `Age element ${index + 1}: ${2016 - el}.`);
console.log(ages6);

//안의 코드가 여러줄인 경우 {}필요
ages6 = years.map((el, index) => {
    const now = new Date().getFullYear();
    const age = now - el;
    return `Age element ${index + 1}: ${age}.`
});
console.log(ages6);
```

## Arrow function의 this

Arrow function은 this keyword를 가지지 않는다.