---
layout: post
title: 모노레포와 TBD로 개발 환경 개선하기
tags: [monorepo, yarn workspace, lerna, turboRepo, nx, pnpm]
excerpt_separator: <!--more-->
---

<!--
왜 모노레포 적용을 생각했는지

우리 회사에는 크게 2가지 프로덕트가 있고, 각 프로덕트에는 여러 프론트 프로젝트가 있다.

모든 TypeScript + React를 사용하기 때문에 겹치는 로직도 많이 발생했고,

앞으로 프로덕트끼리의 연동 계획이 있어 연동을 위한 패키지 모듈을 개발할 계획이 있기 때문에 모노레포로 합치고자 했다.

여러 프로젝트를 하나의 프로젝트에서 한번에 관리할 수 있고, 각 프로젝트간의 의존성 관리를 편리하게 할 수 있게 되었다.

모노레포 도구들을 고를 때, 왜 하필 yarn workspace를 골랐는지.

  full buildSystem(nx, turboRepo)이 있는데, 고르지 않은 이유

도입해서 어떤게 좋아졌는지,

반대로 모노레포의 단점은 무엇인지.

https://medium.com/hcleedev/dev-monorepo-%EA%B0%9C%EB%85%90-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0-33fd3ce2b767

우리는 모노레포를 TBD로 관리 -> TBD 개념과 TBD의 장단점 + TBD를 왜 도입하려고 했는지

conflict의 위험이 있음

TBD를 사용해보니 어떤지.

PR 리뷰에 심혈을 기울이게 된다. main 브랜치가 망가지면 그대로 모든 것이 망가지기 때문에,

우리만의 CI/CD 브랜치 관리 방법

앞으로 develop 계획

lerna를 제외하려는데 왜 그런건지

프로젝트들이 커지고 많아지면서 프로젝트 간에 중복되는 코드들이 생기게 되고 그 로직을 통합하는 과정에서 라이브러리 패키지를 만들게 됩니다.

새로운 프로젝트로 라이브러리 패키지를 개발하고, 그렇게 계속 프로젝트들이 늘어나다보면, 코드 에디터 창이 화면 넘치도록 열리게 됩니다. 😵‍💫

어렵게 어렵게 라이브러리 패키지를 수정하고 PR해서 머지하고 publish한 후에, 해당 라이브러리 패키지를 사용하는 다른 프로젝트들의 버전 갱신까지,,, 엄청난 번거로움이 있습니다. 🫠

(버전 갱신을 잘못하기라도 하는 날엔 프로그램이 터지는 불상사도 일어날 수도 있죠...!🤯)
-->

# MonoRepo

제각각의 프로젝트들을 하나로 묶어주어 편하게 작업할 수 있고, 의존관계 관리도 편리하게 도와주는 것이 바로 오늘의 주제인 **모노레포** 입니다!

지금부터 사내에 **모노레포 도입기**와 **TBD (Trunk-based Development)**를 적용한 경험을 공유하려고 합니다.

모노레포 도입을 고민한 이유와 모노레포 도입과 운영, 그리고 TBD와 TBD를 도입하게 된 경험 순서로 나눠보려고 합니다! 😁

![Monorepo]({{ "../assets/img/monorepo/monorepo_summary.jpeg" | relative_url }})

<!--more-->

# Monorepo 도입 전, Multi-repo들의 난립

2022년 10월 현재 제가 재직 중인 회사엔 2가지 프로덕트가 존재합니다.

각 프로덕트에는 여러 프론트 프로젝트가 존재하고, 모두 TypeScript + React로 이루어진 프로젝트입니다.

하지만, 프로젝트의 config들은 제각각이어서 코드 컨벤션, 커밋 로그 컨벤션 등이 통일이 안되어 있고 dependency들의 버전들도 모두 달랏습니다.

또한, 프로젝트가 서로 다른 컨벤션으로 계속 커지면서 중복되는 로직과 컴포넌트들은 점점 많아져 관리의 소요는 점점 늘어나는 상황이었습니다. 🤯

(같은 코드인데도 서로 다른 컨벤션으로 이해하는데 시간이 소요되고, 중복된 코드들은 복붙으로 서로의 프로젝트를 넘나드는 상황이 되었습니다. 🤦‍♀️)

[끔찍 사진 넣기]

## 먼저 공통 로직들부터 정리하자.

먼저 작은 것부터 정리하기 시작했습니다.

공통되는 로직을 패키지에 묶어 npm private로 배포했습니다.

대표적으로 axios instance를 만들 때, 사내 공통으로 사용되는 config와 interceptor 로직들을 묶어 제공했습니다.

```typescript
class Api {
  serverUrl: string;

  constructor(serverUrl: string) {
    this.serverUrl = serverUrl;

    // 전사적으로 서버가 snake case를 사용하고 있었기에,
    // 이에 맞춰 response시에는 camel case로 request시에는 snake case로 바꿔주는
    // interceptor를 공유했습니다.
    axios.interceptors.response.use((res) => ({
      ...res,
      data: camelizeKeys(res.data),
    }));

    axios.interceptors.request.use((config) => {
      const newConfig = { ...config };

      if (config.params) {
        newConfig.params = decamelizeKeys(config.params);
      }

      if (config.data) {
        newConfig.data = decamelizeKeys(config.data);
      }

      return newConfig;
    });
  }
}
```

이렇게 공통 로직들은 조금씩 정리됐지만,

새롭게 만든 패키지 프로젝트를 따로 관리하면서 배포하고

배포에 맞춰 의존 버전을 갱신하고 이에 맞춰 코드를 바꿔주니 굉장히 번거롭고 불편했습니다. 😿

손이 10개라도 모자랄 지경이었죠.

이런 상황에서 모노레포 환경을 만들 것을 생각하게 됩니다!

# Alla Till mei! (모두 집결하세요!)

모노레포로 FE 소스들을 한 곳에서 관리함으로서 얻는 장점들은 당시 겪고 있던 문제들을 해결해주는데 적합했습니다.

- 동시 다발적인 코드의 변경 사항을 한 눈에 쉽게 파악할 수 있게 됐습니다.

  repo가 나누어져 있을 때는, 각 repo마다 변경된 사항을 확인해야 했었습니다.

  하지만, 어떤 feature는 해당 프로젝트 코드 뿐만아니라 다른 프로젝트의 코드 또한, 수정해야할 경우가 있습니다.

  repo가 여러개 일 경우엔, 코드 변경이 산발적으로 흩어져 있어 이를 맥락적으로 파악하지 못했는데,

  repo가 하나이므로, **맥락에 따른 코드 변경이 한 눈에 들어와 코드 변경을 훨씬 쉽게 파악할 수 있게 되었습니다.**

- config와 lint가 통일됐습니다.

  이렇게 됨으로서 **코드를 일정하게 관리할 수 있게 됐습니다.**

  또한, **새롭게 프로젝트에 투입된 인원의 개발 환경 셋팅도 간편하게 할 수 있게 되었습니다.**

- 하나의 work space에서 여러 프로젝트를 동시에 작업할 수 있게 되었습니다.

  **여러 프로젝트를 넘나들며 필요한 작업을 하는 것 보다 훨씬 효율적으로 작업할 수 있게 됐습니다.**

그렇게 여러 모노레포 도구들을 조사하기 시작했습니다!

# 모노레포 도구들

이제 모노레포 도입을 위해 여러 도구들을 알아보기 시작했습니다!
