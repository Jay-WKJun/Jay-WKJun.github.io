---
layout: post
title: Heaps
tags: [DataStructure, Heaps, Tree]
excerpt_separator: <!--more-->
---

# Heap?

최댓값 및 최솟값을 찾아내는 연산을 빠르게 하기 위해 고안된 완전이진트리(complete binary tree)를 기본으로 한 자료구조(tree-based structure)

보통 Priority Queue를 만들때 사용하고 Graph Traversal에서도 주로 사용된다.

2가지의 형태가 있다.

<!--more-->

## MaxBinaryHeap

부모 node가 child node보다 항상 크다.

## MinBinaryHeap

부모 node가 child node보다 항상 작다.

# 용도

Priority Queue를 만들때 사용한다.

# Tree 구조 형성의 법칙

- 최대한 짧게 만든다. = 좌우를 다 채운다음에 자식을 내린다.
- 왼쪽을 먼저 채운다.
- 친척사이는 서로 전혀 영향을 주지 않는다. = 같은 자식사이라면 서로의 숫자가 뭐가 오든 부모와의 대소 관계가 성립하면 상관 없다.

# Representate as Array

![HeapsToArray]({{ "/assets/img/IT_Pic/RepresentingHeapInArray.PNG | relative_url }})

Heap을 Array로 펼쳐 넣었을 때, 부모와 자식과의 index 관계는 부모의 index를 n이라고 할 때,

Left child Index = 2n + 1

Right child Index = 2n + 2

의 관계를 가진다.

반대로는 (n-1)/2 혹은 (n-2)/2의 관계를 가진다.

# Insert

직접 구현

```java
/*
 Heap : 최댓값 및 최솟값을 찾아내는 연산을 빠르게 하기 위해 고안된 완전이진트리(complete binary tree)를 기본으로 한 자료구조(tree-based structure)
 구현
 - Heap은 bubble up 이라는 동작으로 정렬한다.( = 부모랑 자식이랑 비교해서 위치를 정렬)
 - Array로 구현시 (부모index * 2 + 1) = left , (+ 2) = right이다.
 */
public class Heap {
    public static void main(String[] args) {
        ArrayList<Integer> list = new ArrayList<Integer>();
        list.add(41);
        list.add(39);
        list.add(33);
        list.add(18);
        list.add(27);
        list.add(12);
        Heap heap = new Heap();
        list = heap.insert(list, 55);
        for (int i = 0; i < list.size(); i++){
            System.out.println(list.get(i));
            //result : [55, 39, 41, 18, 27, 12, 33]
        }
    }

    public ArrayList<Integer> insert(ArrayList<Integer> list, int element){
        //가장 끝에 새로 추가 할 것을 넣고
        list.add(element);
        //정렬한다.
        list = bubbleUp(list);
        return list;
    }

    public ArrayList<Integer> bubbleUp(ArrayList<Integer> list){
        int index = list.size() - 1;
        //가장 끝에 추가된 새로운 element를 꺼낸다.
        int element = list.get(index);
        while(index > 0){
            //부모 element를 꺼내서
            int parentIdx = (int)Math.floor((index -1) / 2);
            int parent = list.get(parentIdx);
            //새로운 element와 비교한다.
            if(element > parent){
                //새로운 값이 부모보다 크다면 서로 바꾼다.
                list.remove(parentIdx);
                list.add(parentIdx, element);
                list.remove(index);
                list.add(index, parent);
                index = parentIdx;
            }else{
                //새로운 값이 부모보다 크지 않다면 bubble up을 멈춘다.
                break;
            }
        }
        return list;
    }
}
```