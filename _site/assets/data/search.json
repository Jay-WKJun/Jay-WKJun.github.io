[
  
  {
    "title"    : "Dynamic programing",
    "category" : "",
    "tags"     : " ComputerScience, Algorithms",
    "url"      : "/2020/04/05/Dynamic-Programing.html",
    "date"     : "April 5, 2020",
    "excerpt"  : "Dynamic programing\n\nDynamic programing은 optimization(죄적화) technique 중 하나로 caching(cache를 이용)을 하면 모두 dynamic programing이라 할 수 있다.\n\n하나의 problem을 작은 subproblem으로 쪼개고 subproblem을 하나씩 해결하고 그 solution을 cache에 저장해 나중에 똑같은 problem이 있을때 저장 된 것을 활용하는 방법이다.\n...",
  "content"  : "Dynamic programing\n\nDynamic programing은 optimization(죄적화) technique 중 하나로 caching(cache를 이용)을 하면 모두 dynamic programing이라 할 수 있다.\n\n하나의 problem을 작은 subproblem으로 쪼개고 subproblem을 하나씩 해결하고 그 solution을 cache에 저장해 나중에 똑같은 problem이 있을때 저장 된 것을 활용하는 방법이다.\n\n\n\nimplementing Dynamic programing\n\nDynamic programing = Divide &amp;amp; Conquer + Memoization 으로 구성된다.\n\n아래의 규칙을 따라 implement할 수 있는지 여부를 확인하고 implement할 수 있다.\n\n\n  Can be divided into subproblem?\n  Recursive Solution\n  Are there repetive subproblems?\n  Memoize subproblems\n\n\nWhen can we use dynamic programing?\n\nDynamic programing은 크게 1.Optimal SubStructure 2. Overlapping Subproblems 이 두가지의 경우에 사용 할 수 있다.\n\nOverlapping Subproblems\n\nDefinition : A problem is said to have overlapping subproblems if it can be broken down into subproblems which are reused several times\n\n즉 subproblem으로 쪼개질 수 있고 subproblem을 여러번 사용(overlap)할 경우에 사용할 수 있다.(한번 풀었던 subproblem을 저장했다가 다시 사용하는 거니 당연하다.)\n\nex) fibonacci sequence - 전에 계산했던 결과를 반복하므로 그것을 저장했다가 다시 사용할 수 있다.\n\nmerge sort는 subproblem으로 쪼갤 수 있지만 subproblem이 겹치(overlap)지 않아서 dynamic program을 사용할 수 없다.\n\nOptimal Substructure(최적화 문제)\n\nA problem is said to have optimal substructure if an opitmal solution can be constructed from optimal solutions of its subproblems.\n\n최적화 문제(Optimization problems)란 여러개의 선택가능한 후보 중에서 최적의 해(Optimal value) 또는 최적의 해에 근접한 값을 찾는 문제를 일컫는다. 일반적으로 기계학습 분야에서는 비용함수(Cost function)를 최소화 또는 최대화 시키는 모델의 파라미터(parameter)를 구하게 되는데, 이것은 최적화 문제로 정의될 수 있다.\n\n만약 알파벳으로 여러 지점이 나뉘어 져있는 지도에서 A -&amp;gt; B 로 가는 길이 가장 짧은 길이고 A -&amp;gt; C로 가는 길은 A - B - C 가 가장 짧으며 A -&amp;gt; D로 가는 길은 A - B - C - D일때, A -&amp;gt; D의 경우에 있는 경로에\n\nA-&amp;gt;B, A-&amp;gt;C의 subproblem들이 가장 최적화 된 경로로 A-&amp;gt;D의 경로에 사용되고 있으니 이것은 Optimal subproblem이라 할 수 있다.\n\nMemoization\n\nCaching 방법 중 하나로 똑같은 입력을 똑같은 처리를 해야할 때, cache에 저장된 이미 처리된 결과를 그대로 가져다가 사용하는 것이다.\n\n속도가 크게 개선되며 code도 효율적으로 짤 수 있기 때문에 중요하다.\n\nCaching\n\nCaching은 어떤 문제나 해답, value 등을 cache에 저장해 나중에 활용하는 방법이다.\n\nBackpack이라고 생각하면 쉽다. backpack에 필요한 것을 싸가서 학교에서 필요할 때 꺼내쓰는 것과 같다.\n\nfunction memoizeAddTo80(n) { \n  let cache = {};\n  return function(n) {\n    if (n in cache) {\n      return cache[n];\n    } else {\n      console.log(&#39;long time&#39;);\n      const answer = n + 80;\n      cache[n] = answer;\n      return answer;\n    }\n  }\n}\n\nconst memoized = memoizeAddTo80();\nconsole.log(1, memoized(6))\nconsole.log(2, memoized(6))\nconsole.log(2, memoized(5))\n\n\n\n위의 결과로 처음엔 long time…이 출력되지만 두번째엔 출력되지 않고 이미 저장되어 있는 것을 가져올 것이며 마지막엔 새로 계산해야하므로 long time…이 출력 될 것이다.\n\nfield value인 cache를 지키기 위해 javascript의 closure라는 것을 사용했다. 따라서 해당 function을 호출시 cache가 초기화 되지 않아 Memoization을 제대로 구현 할 수 있다. (return function(n)로 처리부분만 묶음)\n\nExample (optimize fibonacci)\n\nfibonacci는 O(2^n)의 complexity를 갖는데, Memoization을 이용한다면 O(n)으로 줄일 수 있다.\n\n//0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233...\nlet calculations = 0;\nfunction fibonacci(n) { //O(2^n)\n  calculations++;\n  if (n &amp;lt; 2) {\n    return n\n  }\n  return fibonacci(n-1) + fibonacci(n-2);\n}\n\nfunction fibonacciMaster() { //O(n)\n  let cache = {};\n  return function fib(n) {\n    calculations++;\n    if (n in cache) {\n      return cache[n];\n    } else {\n      if (n &amp;lt; 2) {\n        return n;\n      } else {\n        cache[n] = fib(n-1) + fib(n-2);\n        return cache[n];\n      }\n    }\n  }\n}\nconsole.log(&#39;Slow&#39;, fibonacci(35))\nconsole.log(&#39;we did &#39; + calculations + &#39; calculations&#39;);  //29860703\nconsole.log(&#39;DP&#39;, fasterFib(100));\nconsole.log(&#39;we did &#39; + calculations + &#39; calculations&#39;);  //69\n\n\nalgorithm은 그대로에 cache 저장과 출력만 추가 했을 뿐인데 complexity가 비약적으로 좋아졌다.\n\ncalculations의 결과를 보면 알 수 있다.\n\nBottom up approach\n\n이것 또한 dynamic programing의 방법 중 하나로 위의 memoization이 top down approach(recursion)이었다면 이 방법은 반대이다.\n\nfibonacci에서 n부터 시작하는게 아니라 1,2부터 시작해서 n까지 연산해서 올라간다.(가장 작은 subproblem부터 타고 올라간다),전 계산 결과를 table에 담고 그것을 다시 사용한다. 이렇게 table에 결과들을 담아가는 것을 “Tabulant”라고 한다.\n\n장점은 memoization을 사용하는 top-down에선 call stack을 쌓아놓고 base case에서 풀면서 오지만 bottom-up에선 전에 계산한 것을 바로 사용하기 때문에 stack을  사용하지 않아 space complexity가 훨씬 좋다.(fib(100000)인 경우 bottom-up은 overflow가 일어나지 않는다.)\n\ncode가 훨씬 직관적이고 recursion을 사용하지않지만 다른 case에 적용하기 어렵다는 단점이 있다.(code를 보면 반드시 저번에 계산했던 결과를 사용해야만 한다.)\n\nfunction fibonacciMaster2(n) {\n  let answer = [0,1];\n  for ( let i = 2; i &amp;lt;= n; i++) {\n    answer.push(answer[i-2]+ answer[i-1]);\n  }\n  return answer.pop();\n}\n\n"
} ,
  
  {
    "title"    : "Searching",
    "category" : "",
    "tags"     : " ComputerScience, Algorithms",
    "url"      : "/2020/04/02/Searching.html",
    "date"     : "April 2, 2020",
    "excerpt"  : "Searching\n\n검색은 실생활에서도 자주 사용하는 것으로 Sorting보다는 훨씬 자주 접한다.\n\n\n\nLinear search\n\n처음부터 하나씩 확인해가며 찾는 search 방법. 따라서 O(n)이다.\n\nBinary search\n\n중간값을 골라서 찾는 값과 비교, 찾는 값이 중간값보다 오른쪽이면 왼쪽 모두 버리고 반대도 마찬가지이다. 혹은 값이 크거나 작거나를 비교해서 진행할 수도 있다. 따라서 O(log (n))\n\n이것은 Binary...",
  "content"  : "Searching\n\n검색은 실생활에서도 자주 사용하는 것으로 Sorting보다는 훨씬 자주 접한다.\n\n\n\nLinear search\n\n처음부터 하나씩 확인해가며 찾는 search 방법. 따라서 O(n)이다.\n\nBinary search\n\n중간값을 골라서 찾는 값과 비교, 찾는 값이 중간값보다 오른쪽이면 왼쪽 모두 버리고 반대도 마찬가지이다. 혹은 값이 크거나 작거나를 비교해서 진행할 수도 있다. 따라서 O(log (n))\n\n이것은 Binary search Tree와 동일한 원리로 검색이 이루어진다. 따라서 sorting되어 있을 때 가장 빠르다(O(log (n)))는 점도 똑같다.\n\nTraversal\n\nGraph와 Tree의 데이터구조에서 모든 원소들(n)을 들를 때 Traversal이라고 한다. 모든 원소를 거치기 때문에 O(n)이다.\n\nvisualGo의 Traversal Animation\n\nhttps://visualgo.net/en/dfsbfs?slide=1\n\nBreath First Search\n\n이것은 가로로 훑는 방법으로 Tree일땐 왼쪽에서 오른쪽으로~ 밑으로 내려가서 끝까지 반복이다.\n\nDFS보다 많은 메모리가 필요하다. 이유는 한 level의 node를 모두 저장해야 하기 때문이다.\n\n\n  \n    \n      pros\n      cons\n    \n  \n  \n    \n      Shotest path\n      More Memory\n    \n    \n      Closer Nodes\n       \n    \n  \n\n\npros의 말은 root node에서 가장 가깝다는 말이다.\n\nshortest path는 모든 level의 node를 확인하고 가기 때문에 어떤 node까지 가는데 가장 최적화 된 path를 찾을 수 있다는 것이다.\n\n  BreadthFirstSearch(){\n    let currentNode = this.root;\n    let list = [];\n    let queue = [];\n    queue.push(currentNode);\n\n    while(queue.length &amp;gt; 0){\n      currentNode = queue.shift();\n      list.push(currentNode.value);\n      if(currentNode.left) {\n        queue.push(currentNode.left);\n      }\n      if(currentNode.right) {\n        queue.push(currentNode.right);\n      }\n    }\n    return list;\n  }\n  \n  BreadthFirstSearchR(queue, list) {\n    if (!queue.length) {\n      return list;\n    }\n    const currentNode = queue.shift();\n    list.push(currentNode.value);\n    \n    if (currentNode.left) {\n      queue.push(currentNode.left);\n    }\n    if (currentNode.right) {\n      queue.push(currentNode.right);\n    }\n    \n    return this.BreadthFirstSearchR(queue, list);\n  }\n\n\nDepth First Search\n\n세로로 훑는 방법으로 끝까지 내려갔다가 올라와서 훑고 반복이다. 이것도 주로 왼쪽부터 시작한다.\n\nBFS보다 적은 메모리가 든다. 이유는 각 level의 모든 child들을 가지고 있을 필요가 없기 때문이다.(필요할때 child를 찾아가면 됨.) Space complexity는 깊이 끝까지 찾기 때문에 O(depth)이다.(code를 보면 알 수 있다.)\n\nDFS를 시작할 땐, inorder(왼 중 오), preorder(중 왼 오), postorder(왼 오 중)의 방법이 있다.\n\npreorder는 tree의 모양대로 정렬이 되어있기 때문에 tree를 재정렬할 떄 매우 유용하다.\n\n//     9\n//  4     20\n//1  6  15  170\n\nInOrder - [1, 4, 6, 9, 15 ,20 ,170]\nPreOrder - [9, 4, 1, 6, 20, 15, 170]\nPostOrder - [1, 6, 4, 15, 170, 20, 9]\n\n\n\n  \n    \n      pros\n      cons\n    \n  \n  \n    \n      Less Memory\n      can get slow\n    \n    \n      Does path exist?\n       \n    \n  \n\n\nTarget이 존재하는지, target까지의 path가 존재하는지 깊게 들어가기 때문에 빠르게 찾을 수 있다.\n\nTree와 Graph는 매우 깊기때문에 전체 검색 속도가 느릴 수 있다.\n\n  DFTPreOrder(currentNode, list) {\n    return traversePreOrder(this.root, []);\n  }\n  DFTPostOrder(){\n    return traversePostOrder(this.root, []); \n  }\n  DFTInOrder(){\n    return traverseInOrder(this.root, []);\n  }\n\n\nfunction traversePreOrder(node, list){\n  list.push(node.value);\n  if(node.left) {\n    traversePreOrder(node.left, list);\n  }\n  if(node.right) {\n    traversePreOrder(node.right, list);\n  }\n  return list;\n}\n\nfunction traverseInOrder(node, list){\n  if(node.left) {\n    traverseInOrder(node.left, list);\n  }\n  list.push(node.value);\n  if(node.right) {\n    traverseInOrder(node.right, list);\n  }\n  return list;\n}\n\nfunction traversePostOrder(node, list){\n  if(node.left) {\n    traversePostOrder(node.left, list);\n  }\n  if(node.right) {\n    traversePostOrder(node.right, list);\n  }\n  list.push(node.value);\n  return list;\n}\n\n\nValidate Binary Search Tree\n\ninterview에서 자주 묻는 질문이다. binary search tree가 규칙대로 되어있는가를 확인하는 것이다. 보통 BFS가 유용하다.\n\nhttps://leetcode.com/problems/validate-binary-search-tree/\n\nGraph Traversals\n\nBFS, DFS\n\nTree는 Graph의 한 종류이므로 같은 원리로 Traversal을 할 수 있다.\n\n중요한건 BFS와 DFS의 쓰임인데 Graph는 실생활과 밀접한 관련이 있는 데이터 구조이기 때문에, 실제로도 많이 사용되고 있다.\n\nBFS in Graph\n\nBFS - Shortest path\n\nex) Amazon의 recommendation system, Facebook의 현재 가장 가까운 친구, Google map의 길찾기\n\nDFS in Graph\n\nDFS - Check to see if it exists, maze를 풀어내는 것과 같다.\n\nDijkstra &amp;amp; Bellman - Ford Algorithms\n\n둘 다 weighted graph에서 shortest path를 찾는 알고리즘으로 효율적이며 각자 특징이 있다.\n\nDijkstra - negative edge가 있으면 사용 불가능, Bellman - Ford보다 더 효율적이다.\n\nBellman - Ford - negative weight가 있어도 사용 가능, Dijkstra비해 complexity가 비효율적(worst case O(n^2))\n\nself implement\n\nclass Node {\n\tNode left, right;\n\tint data;\n\n\tNode(int data) {\n\t\tthis.data = data;\n\t\tleft = right = null;\n\t}\n}\n\npublic class BSTLevelOrderTraversal {\n\n\tstatic Queue&amp;lt;Node&amp;gt; queue = new ArrayDeque&amp;lt;&amp;gt;();\n\n\tstatic void levelOrder(Node root) {\n\t\t// Write your code here\n\n\t\tif (root == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tSystem.out.print(root.data + &quot; &quot;);\n\n\t\tif (root.left != null) {\n\t\t\tqueue.add(root.left);\n\t\t}\n\n\t\tif (root.right != null) {\n\t\t\tqueue.add(root.right);\n\t\t}\n\n\t\tlevelOrder(queue.poll());\n\n\t}\n\n\tpublic static Node insert(Node root, int data) {\n\t\tif (root == null) {\n\t\t\treturn new Node(data);\n\t\t} else {\n\t\t\tNode cur;\n\t\t\tif (data &amp;lt;= root.data) {\n\t\t\t\tcur = insert(root.left, data);\n\t\t\t\troot.left = cur;\n\t\t\t} else {\n\t\t\t\tcur = insert(root.right, data);\n\t\t\t\troot.right = cur;\n\t\t\t}\n\t\t\treturn root;\n\t\t}\n\t}\n\n\tpublic static void depthFirstSearch(Node node) {\n\t\tif (node == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tSystem.out.print(node.data + &quot; &quot;);\n\n\t\tdepthFirstSearch(node.left);\n\t\tdepthFirstSearch(node.right);\n\n\t}\n\tpublic static void depthFirstSearchIn(Node node) {\n\t\t\n\t\t//System.out.println(++count);\n\t\tif (node == null) {\n\t\t\treturn;\n\t\t}\n\t\tdepthFirstSearchIn(node.left);\n\t\tSystem.out.print(node.data + &quot; &quot;);\n\t\tdepthFirstSearchIn(node.right);\n\t}\n\n\tpublic static void depthFirstSearchPost(Node node) {\n\n\t\tif (node == null) {\n\t\t\treturn;\n\t\t}\n\t\tdepthFirstSearchPost(node.left);\n\t\tdepthFirstSearchPost(node.right);\n\t\tSystem.out.print(node.data + &quot; &quot;);\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tNode root = null;\n\n\t\tint[] data = { 3, 5, 4, 7, 2, 1 };\n\n\t\tfor (int i = 0; i &amp;lt; data.length; i++) {\n\t\t\troot = insert(root, data[i]);\n\t\t}\n\n\t\t//   3\n\t\t//  2   5\n\t\t// 1   4 7\n\t\tSystem.out.println(&quot;BFS&quot;);\n\t\tlevelOrder(root);\n\t\tSystem.out.println();\n\t\t\n\t\tSystem.out.println(&quot;DFS preorder&quot;);\n\t\tdepthFirstSearch(root);\n\t\tSystem.out.println();\n\t\t\n\t\tSystem.out.println(&quot;DFS inorder&quot;);\n\t\tdepthFirstSearchIn(root);\n\t\tSystem.out.println();\n\t\t\n\t\tSystem.out.println(&quot;DFS postorder&quot;);\n\t\tdepthFirstSearchPost(root);\n\t}\n}\n\n"
} ,
  
  {
    "title"    : "Sorting",
    "category" : "",
    "tags"     : " ComputerScience, Algorithms",
    "url"      : "/2020/03/31/Sorting.html",
    "date"     : "March 31, 2020",
    "excerpt"  : "Sorting\n\n우리말로 “정렬”로 데이터를 정렬하는 것이다.\n\nSorting은 데이터의 규모가 커질 수록 중요해진다. 작은 데이터일 경우엔 언어에 내장된 메소드를 이용하면되지만 데이터가 10억 규모가 되면 이야기가 달라진다.\n\n(이를 위해 wikipedia에는 수많은 sorting 알고리즘이 있지만 이것은 advanced 알고리즘으로 여기선 기초만 다룬다.)\n\n데이터 규모가 커지면 커질수록 Data Handle에 cost가 기하급수적으로...",
  "content"  : "Sorting\n\n우리말로 “정렬”로 데이터를 정렬하는 것이다.\n\nSorting은 데이터의 규모가 커질 수록 중요해진다. 작은 데이터일 경우엔 언어에 내장된 메소드를 이용하면되지만 데이터가 10억 규모가 되면 이야기가 달라진다.\n\n(이를 위해 wikipedia에는 수많은 sorting 알고리즘이 있지만 이것은 advanced 알고리즘으로 여기선 기초만 다룬다.)\n\n데이터 규모가 커지면 커질수록 Data Handle에 cost가 기하급수적으로 오르기 때문에 큰 기업들에선 Sorting을 매우 중요하게 생각하며, 같은 이유로 interview에서도 마찬가지로 중요한 주제이다.\n\n직접 scratch로 coding할 일은 없지만 상황에 따라 각 sorting algorithm의 장단점을 따져서 가장 적절한 것을 선택해서 쓸 줄 알아야한다.\n\n\n\n아래 페이지에서 각 sorting을 animation으로 볼 수 있다.\n\nhttps://www.toptal.com/developers/sorting-algorithms\n\nDon’t always trust built in method in your language\n\nbuilt in인 sort method를 항상 믿으면 안된다.\n\njavascript의 경우 문자의 가장 앞자리를 UTF-16의 encoding형태로 서로 비교하여 sorting하기 때문에 원하는 답이 안나올 수도 있다. int가 2자리 이상인 경우도 마찬가지이다.\n\n게다가 문서엔 browser에 따라 처리속도와 필요 메모리가 바뀔 수 있다고 하니 주의해야한다.(javascript의 ECMAscript로 인해 browser에 내장되어 있는 engine에 따라 다르게 작동한다.)\n\nChrome V8 engine : Quick sort or insertion sort(in small case)\n\nMozilla firefox engine : Merge sort\n\njavascript의 sort method API document\n\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\n\nconst months = [&#39;March&#39;, &#39;Jan&#39;, &#39;Feb&#39;, &#39;Dec&#39;];\nmonths.sort();\nconsole.log(months);\n// expected output: Array [&quot;Dec&quot;, &quot;Feb&quot;, &quot;Jan&quot;, &quot;March&quot;]\n\nconst array1 = [1, 30, 4, 21, 100000];\narray1.sort();\nconsole.log(array1);\n// expected output: Array [1, 100000, 21, 30, 4]\n\n//이렇게하면 보완이 가능하다.\nconst array2 = [2, 65, 34, 2, 1, 7, 8]\narray2.sort(function(a,b){\n\treturn a - b;\n})\n// expected output: Array [1, 2, 2, 7, 8, 34, 65]\n\n\nBubble sort\n\n양 옆의 갚을 비교 하여 정렬하고 nested loop을 통해 완성한다. [O(n^2)]\n\nconst numbers = [99, 44, 6, 2, 1, 5, 63, 87, 283, 4, 0];\n\nfunction bubbleSort(array) {\n  var length = array.length;\n  for(var i = 0; i &amp;lt; length; i++){\n    for(var j = 0; j &amp;lt; length-i; j++){\n      if(array[j] &amp;gt; array[j+1]){\n        var temp = array[j+1]\n        array[j+1] = array[j]\n        array[j] = temp\n      }\n    }\n  }\n  return array;\n}\n\nbubbleSort(numbers);\nconsole.log(numbers);\n\n\nSelection Sort\n\nList를 모두 훑으면서 가장 작은 값을 찾고 그 값을 해당 loop의 순번에 넣는다. 이것을 nested loop로 반복 [O(n^2)]\n\nconst numbers = [99, 44, 6, 2, 1, 5, 63, 87, 283, 4, 0];\n\nfunction selectionSort(array) {\n  for(var i = 0; i&amp;lt;array.length-1;i++){\n    for(var j = i+1; j&amp;lt;array.length;j++){\n      if(array[i] &amp;gt; array[j]){\n        var temp = array[j]\n        array[j] = array[i]\n        array[i] = temp;\n      }\n    }\n  }\n  return array;\n}\n\nselectionSort(numbers);\n\n\nInsertion sort\n\n거의 sorting되어 있고 small data set이면 Insertion sorting이 가장 빠르다.\n\nconst numbers = [99, 44, 6, 2, 1, 5, 63, 87, 283, 4, 0];\n\nfunction insertionSort(array) {\n  const length = array.length;\n\tfor (let i = 0; i &amp;lt; length; i++) {\n\t\tif (array[i] &amp;lt; array[0]) {\n      //move number to the first position\n      array.unshift(array.splice(i,1)[0]);\n    } else {\n      // only sort number smaller than number on the left of it. This is the part of insertion sort that makes it fast if the array is almost sorted.\n      if (array[i] &amp;lt; array[i-1]) {\n        //find where number should go\n        for (var j = 1; j &amp;lt; i; j++) {\n          if (array[i] &amp;gt;= array[j-1] &amp;amp;&amp;amp; array[i] &amp;lt; array[j]) {\n            //move number to the right spot\n            array.splice(j,0,array.splice(i,1)[0]);\n          }\n        }\n      }\n    }\n\t}\n}\n\ninsertionSort(numbers);\nconsole.log(numbers);\n\n\nMerge Sort\n\n배열을 반으로 쪼개고 쪼개 1개까지 쪼개서 양옆의 배열의 값과 비교하고 합병하면서 sorting한다.(Divide and Conquer) O(n log(n)), O(n)\n\n위의 sorting보다 빠르다는게 장점이다, 메모리가 더 많이 필요한게 단점\n\nconst numbers = [99, 44, 6, 2, 1, 5, 63, 87, 283, 4, 0];\n\nfunction mergeSort (array) {\n  if (array.length === 1) {\n    return array\n  }\n  // Split Array in into right and left\n  const length = array.length;\n  const middle = Math.floor(length / 2)\n  const left = array.slice(0, middle) \n  const right = array.slice(middle)\n  // console.log(&#39;left:&#39;, left);\n  // console.log(&#39;right:&#39;, right);\n\n  \n  return merge(\n    mergeSort(left),\n    mergeSort(right)\n  )\n}\n\nfunction merge(left, right){\n  const result = [];\n  let leftIndex = 0;\n  let rightIndex = 0;\n  while(leftIndex &amp;lt; left.length &amp;amp;&amp;amp; \n        rightIndex &amp;lt; right.length){\n     if(left[leftIndex] &amp;lt; right[rightIndex]){\n       result.push(left[leftIndex]);\n       leftIndex++;\n     } else{\n       result.push(right[rightIndex]);\n       rightIndex++\n    }\n  }  \n  //console.log(left, right)\n  return result.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));\n}\n\nconst answer = mergeSort(numbers);\nconsole.log(answer);\n\n\npublic class MergeSortSoloReview {\n\t\n\tint count = 0;\n\t\n\t//처음에 쪼개고 쪼개서 하나로 만들고(call stack을 쌓고) 하나를 리턴해서 병합하고 리턴하고 반복...\n\tpublic int[] divideAndMerge(int [] a) {\n\t\tSystem.out.println(&quot;divide count = &quot; + ++count);\n\t\t//a가 하나로 쪼개지면 그대로 리턴한다.(base case)\n\t\tif(a.length == 1) {\n\t\t\tSystem.out.println(&quot;return : &quot; + a[0]);\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\tint mid = a.length / 2; //오른쪽 파티션의 첫번째 인덱스이다.\n\t\tSystem.out.println(&quot;mid = &quot; + mid);\n\t\t\n\t\tint[] left = new int[mid];\n\t\t\n\t\tfor (int i = 0; i &amp;lt; left.length; i++) {\n\t\t\tleft[i] = a[i];\n\t\t}\n\t\t\n\t\tint[] right = new int [a.length - mid];\n\t\t\n\t\tfor (int i = 0; i &amp;lt; right.length; i++) {\n\t\t\tright[i] = a[i+mid];\n\t\t}\n\t\t\n\t\tSystem.out.println(&quot;divided : &quot;);\n\t\tscan(left);\n\t\tscan(right);\n\t\t\n\t\t//쪼갰으니 병합해서 리턴해야한다.\n\t\t//하나가 남을때까지 반복적으로 쪼개야하므로 이렇게 불러야한다.\n\t\t//base case 조건 : array가 하나일 것\n\t\t//자신의 작업을 다시 사용할 필요가 없다면 base case조건을 통해 리턴을 유도하는게 중요하다!\n\t\t//base case에 다다르면 left와 right는 재귀하지 않고 자신을 리턴할 것이고\n\t\t//right도 마찬가지로 자신을 재귀하면 merge를 시작하게 된다. = 마지막 하나일때 merge를 시작함\n\t\t//merge를해서 결과를 리턴했으므로 그 전에 불럿던 divdeAndMerge함수하나는 리턴값을 가지고 다시 divide를 부르지 않는다.\n\t\t//반대쪽도 마찬가지... 따라서 merge하고 다시 리턴값을 위로 올려서 가장 위에까지 반복....\n\t\treturn merge(divideAndMerge(left),divideAndMerge(right));\n\t}\n\t\n\t//합치기 위한 함수\n\t//divde를 재귀하지 않고 리턴하면 merge 함수의 조건이 만족되어서 merge를 하게 된다. = 끝가지 divide반복 후 merge하며 돌아옴\n\tpublic int[] merge (int[] left, int []right) {\n\t\tSystem.out.println(&quot;merge : &quot;);\n\t\tscan(left);\n\t\tscan(right);\n\t\tint[] result = new int[left.length + right.length];\n\t\tint leftindex = 0;\n\t\tint rightindex = 0;\n\t\tint resultindex = 0;\n\t\twhile(leftindex &amp;lt;= left.length-1) {\n\t\t\tresult[resultindex] = left[leftindex];\n\t\t\tresultindex++;\n\t\t\tleftindex++;\n\t\t}\n\t\twhile(rightindex &amp;lt;= right.length-1) {\n\t\t\tresult[resultindex] = right[rightindex];\n\t\t\tresultindex++;\n\t\t\trightindex++;\n\t\t}\n\t\t\n\t\t//insertion sort\n\t\tfor (int i = 1; i &amp;lt; result.length; i++) {\n\t\t\tif (result[0] &amp;gt; result[i]) {\n\t\t\t\tint temp = result[0];\n\t\t\t\tresult[0] = result[i];\n\t\t\t\tresult[i] = temp;\n\t\t\t}\n\t\t\tif(result[i] &amp;lt; result[i-1]) {\n\t\t\t\tfor (int j = i; j &amp;gt;= 0; j--) {\n\t\t\t\t\tint temp = result[j];\n\t\t\t\t\tresult[j] = result[j-1];\n\t\t\t\t\tresult[j-1] = temp;\n\t\t\t\t\tif (result[j-2] &amp;lt; result [j-1] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(&quot;merge result : &quot;);\n\t\tscan(result);\n\t\treturn result;\n\t}\n\t\n\tpublic void scan(int [] a) {\n\t\tfor (int i = 0; i &amp;lt; a.length; i++) {\n\t\t\tSystem.out.print(a[i]+&quot; &quot;);\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\tint [] arr = {99, 44, 6, 2, 1, 5, 63, 87, 283, 4, 0};\n\t\t\n\t\tMergeSortSoloReview n = new MergeSortSoloReview();\n\t\tint[] result = n.divideAndMerge(arr);\n\t\t/*\n\t\t * for (int i = 0; i &amp;lt; result.length; i++) { System.out.println(result[i]+&quot; &quot;);\n\t\t * } System.out.println();\n\t\t */\n\t}\n\t\n}\n\n\nQuick Sort\n\nQuick sort는 array에서 pivot이라는 기준을 두어 정렬을 시도한다. O(n log(n)), O(log(n)), merge sort보다 space complexity면에서 우수하다. average속도도 실질적으론 merge보다 빠르다.\n\npivot의 선정방식은 random이며 여러가지 방법 들이 있다. pivot의 왼쪽은 pivot보다 항상 작아야하고 오른쪽은 항상 크도록 정렬한다.\n\n따라서 pivot을 적절한 위치로  정렬해야하는데 pivot의 정렬방식은 여러가지이다. pivot이 정렬되었으면 array을 둘로 쪼개고 똑같은 작업을 반복한다음 정렬이 끝나면 하나의 array로 합병하여 끝낸다.\n\n하지만 pivot이 가장 크거나 작고 혹은 array 가장 끝에 있으면 O(n^2)이라는 끔찍하게 느린 속도가 나오므로 적절한 pivot 선정이 매우 중요하다.\n\nconst numbers = [99, 44, 6, 2, 1, 5, 63, 87, 283, 4, 0];\n\nfunction quickSort(array, left, right){\n  const len = array.length; \n  let pivot;\n  let partitionIndex;\n\n  if(left &amp;lt; right) {\n    pivot = right;\n    partitionIndex = partition(array, pivot, left, right);\n    \n    //sort left and right\n    quickSort(array, left, partitionIndex - 1);\n    quickSort(array, partitionIndex + 1, right);\n  }\n  return array;\n}\n   \nfunction partition(array, pivot, left, right){\n  let pivotValue = array[pivot];\n  let partitionIndex = left;\n\n  for(let i = left; i &amp;lt; right; i++) {\n    if(array[i] &amp;lt; pivotValue){\n      swap(array, i, partitionIndex);\n      partitionIndex++;\n    }\n  }\n  swap(array, right, partitionIndex);\n  return partitionIndex;\n}\n\nfunction swap(array, firstIndex, secondIndex){\n    var temp = array[firstIndex];\n    array[firstIndex] = array[secondIndex];\n    array[secondIndex] = temp;\n}\n\n//Select first and last index as 2nd and 3rd parameters\nquickSort(numbers, 0, numbers.length - 1);\nconsole.log(numbers);\n\n\npublic class QuickSortSoloReview {\n\tint count = 0;\n\t\n\tpublic void quicksort(int[] a, int left, int right) {\n\t\t//오른쪽 시작위치까지\n\t\tint partition = partition(a, left, right);\n\t\t\n\t\tif(left &amp;lt; partition-1) { // 오른쪽 파티션 시작점 바로 전이 왼쪽파티션의 시작점이면 왼쪽 파티션이 1개남았단 소리로 발동 스킵\n\t\t\tquicksort(a, left, partition-1);\t//왼쪽 파티션\n\t\t}\n\t\tif (right &amp;gt; partition) {\t// 파티션 시작점이 가장 끝점이랑 같다면 오른쪽 파티션엔 하나남았던 소리로 발동 스킵\n\t\t\tquicksort(a, partition, right);\t\t//오른쪽 파티션\n\t\t}\n\t\t\n\t}\n\t\n\tpublic int partition(int[] a, int left, int right) {\n\t\tcount++;\n\t\tint pivot = (left+right)/2;\n\t\t//(피봇과 같아도 오케이기때문에 마지막엔 피봇을 넘겨버린다.)\n\t\tSystem.out.println(count + &quot;번째 &quot; + &quot;pivot = &quot; + a[pivot]);\n\t\tdoprint(a);\n\t\twhile(left &amp;lt;= right) {\n\t\t\t//왼쪽에 피봇보다 큰게 있을 떄 까지 index움직임\n\t\t\twhile(a[left] &amp;lt; a[pivot]) {\n\t\t\t\tleft++;\n\t\t\t}\n\t\t\t//오른쪽에 피봇보다 작은게 있을 때 까지 index를 움직인다.\n\t\t\twhile(a[right] &amp;gt; a[pivot]) {\n\t\t\t\tright--;\n\t\t\t}\n\t\t\tif (left &amp;lt;= right) {\n\t\t\t\tSystem.out.println(&quot;left = &quot; + left + &quot; right = &quot; + right);\n\t\t\t\tSystem.out.println(&quot;swap - left = &quot; + a[left] + &quot; right = &quot;+ a[right]);\n\t\t\t\tint temp = a[left];\n\t\t\t\ta[left] = a[right];\n\t\t\t\ta[right] = temp;\n\t\t\t\tleft++;\n\t\t\t\tright--;\n\t\t\t}\t\n\t\t}\n\t\tdoprint(a);\n\t\tSystem.out.println(&quot;return  = &quot; + left);\n\t\t\n\t\treturn left;\t//오른쪽 파티션의 시작점을 반환한다.\n\t}\n\t\n\tpublic void doprint(int[] a) {\n\t\tfor (int i = 0; i &amp;lt; a.length; i++) {\n\t\t\tSystem.out.print(a[i] + &quot; &quot;);\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tQuickSortSoloReview q = new QuickSortSoloReview();\n\t\t\n\t\t//int [] arr = {99, 44, 6, 2, 1, 5, 63, 87, 283, 4, 0};\n\t\tint [] arr = {1,2,3,4,5,6};\n\t\t\n\t\tq.quicksort(arr, 0 ,arr.length-1);\n\t\t\n\t\tfor (int i = 0; i &amp;lt; arr.length; i++) {\n\t\t\tSystem.out.print(&quot; &quot; + arr[i]);\n\t\t}\n\t\t\n\t}\n}\n\n\n\nHeap Sort\n\nMerge sort와 비슷한 원리로 sorting한다. space complexity가 merge나 quick보다 좋지만 average속도가 앞의 둘 보다 느리다. O(n log(n)) O(1)\n\n실제로는 quick 사용시 bad case 발견시 heap sort로 전환하여 sorting속도를 높인다고 한다.\n\n원리 animation\n\nhttps://brilliant.org/wiki/heap-sort/\n\nQuick vs Heap\n\nhttps://stackoverflow.com/questions/2467751/quicksort-vs-heapsort\n\nnon-comparison sort\n\nSorting에서 O(n log(n))의 속도는 수학적으로 절대 넘을 수 없다. 두개의 값들을 모두 비교(comparison)하기 때문이다.\n\n그렇다면 비교하지 않는다면…? 저 속도를 넘을 수 있을 것이다. radix sort, counting sort가 그것이다.\n\n저 둘은 int가 이진수로 저장되어있는 원리를 이용한 것으로 속도가 radix = O(nk) counting = O(n+k)로 속도가 매우 빨라진다.\n\n하지만 원리의 특성상 특정 자릿수(10조같은 너무 큰 수) 이하의 Integer data type만 사용가능하다.\n\nRadix Sort: https://brilliant.org/wiki/radix-sort/\n\nRadix Sort Animation: https://www.cs.usfca.edu/~galles/visualization/RadixSort.html\n\nCounting Sort: https://brilliant.org/wiki/counting-sort/\n\nCounting Sort Animation: https://www.cs.usfca.edu/~galles/visualization/CountingSort.html\n"
} ,
  
  {
    "title"    : "Java Note",
    "category" : "",
    "tags"     : " Java, APIs",
    "url"      : "/2020/03/30/Java.html",
    "date"     : "March 30, 2020",
    "excerpt"  : "What is this for?\n\nJava에 대한 까먹기 쉬운 skill들을 모아 놓는다.\n",
  "content"  : "What is this for?\n\nJava에 대한 까먹기 쉬운 skill들을 모아 놓는다.\n"
} ,
  
  {
    "title"    : "Graphs",
    "category" : "",
    "tags"     : " ComputerScience, DataStructure",
    "url"      : "/2020/03/30/Graphs.html",
    "date"     : "March 30, 2020",
    "excerpt"  : "Graphs\n\nGraph는 현실을 구현하는데 가장 유용한 Data Structure이다.(그렇기에 Scailing이 가장 어렵다.)\n\nWorld Wide Web, SNS 등의 모두 Graph로 되어 있고 실제로도 사용하고 있다.\n\nNeo4j라는 회사가 Graph 형태 Database를 제공한다고 한다.\n\n\n\n\n\nType of graphs\n\nDirected vs Undirected\n\n\n\n-Directed : 특정 방향으로만 연결 된다. ex...",
  "content"  : "Graphs\n\nGraph는 현실을 구현하는데 가장 유용한 Data Structure이다.(그렇기에 Scailing이 가장 어렵다.)\n\nWorld Wide Web, SNS 등의 모두 Graph로 되어 있고 실제로도 사용하고 있다.\n\nNeo4j라는 회사가 Graph 형태 Database를 제공한다고 한다.\n\n\n\n\n\nType of graphs\n\nDirected vs Undirected\n\n\n\n-Directed : 특정 방향으로만 연결 된다. ex)Twitter 트위터는 팔로우하면 자동으로 팔로우 한사람과 서로 팔로우 되지 않는다.\n-Undirected : 무조건 양바향으로 연결 된다. ex)Facebook 친구를 하면 서로 친구가 된다.\n\nWeighted vs Unweighted\n\n\n\n-Weighted : node마다 숫자 value가 있고 Edge마다 value가 있다. ex)Google map 특정 장소를 찾아서(node의 value를 검색) 가장 빠른 경로를 찾는다(Edge들의 value분석).\n-Unweighted : node마다 value가 있지만 Edge에 value는 없다.\n\nCyclic vs Acyclic\n\n\n\n-Cyclic : 각 node가 서로 연결되어 있는 상태 Cyclic은 특히 Weighted Graph에서 자주 보이는 형태이다.\n-Acyclic : 각 node가 서로 연결되어 있지 않는 상태\n\nGraph Data\n\n아래와 같은 graph가 있다고 할 때 이것을 어떻게 data화 시켜 프로그램에서 다룰 것인가??\n\n\n\nAdjacent Matrix\n\nconst graph = [[0,2], [2,3], [2,1], [1,3]];\n\n\n0과 2가 연결되어 있다, 2와 3이 연결되어 있다, 2와 1이 연결되어 있다, 1과 3이 연결되어 있다\n\nAdjacent List\n\nconst graph = [[2], [2,3], [0,1,3], [1,2]];\n\n\n0은 2와 근접해있다, 1은 2,3과 근접해있다, 2는 0,1,3과 인접해있다, 3은  1,2와 인접해 있다\n\nHashTable을 이용해 key값을 node의 value로 한다면 한층 다루기 편해질 것.\n\nEdge List\n\nconst graph = [\n\t0: [0,0,1,0], \n\t1: [0,0,1,1], \n\t2: [1,0,1,1], \n\t3: [0,1,1,0]\n];\n\n\n0은 2번과 접해있다. 1은 2와 3과 접해있다.\n\nExcercise\n\nclass Graph { \n  constructor() { \n    this.numberOfNodes = 0; \n    this.adjacentList = {}; \n  } \n  addVertex(node)  { \n    this.adjacentList[node] = []; \n    this.numberOfNodes++;\n  } \n  addEdge(node1, node2) { \n    //uniderected Graph \n    this.adjacentList[node1].push(node2); \n    this.adjacentList[node2].push(node1); \n  } \n  showConnections() { \n    const allNodes = Object.keys(this.adjacentList); \n    for (let node of allNodes) { \n      let nodeConnections = this.adjacentList[node]; \n      let connections = &quot;&quot;; \n      let vertex;\n      for (vertex of nodeConnections) {\n        connections += vertex + &quot; &quot;;\n      } \n      console.log(node + &quot;--&amp;gt;&quot; + connections); \n    } \n  } \n} \n\nvar myGraph = new Graph();\nmyGraph.addVertex(&#39;0&#39;);\nmyGraph.addVertex(&#39;1&#39;);\nmyGraph.addVertex(&#39;2&#39;);\nmyGraph.addVertex(&#39;3&#39;);\nmyGraph.addVertex(&#39;4&#39;);\nmyGraph.addVertex(&#39;5&#39;);\nmyGraph.addVertex(&#39;6&#39;);\nmyGraph.addEdge(&#39;3&#39;, &#39;1&#39;); \nmyGraph.addEdge(&#39;3&#39;, &#39;4&#39;); \nmyGraph.addEdge(&#39;4&#39;, &#39;2&#39;); \nmyGraph.addEdge(&#39;4&#39;, &#39;5&#39;); \nmyGraph.addEdge(&#39;1&#39;, &#39;2&#39;); \nmyGraph.addEdge(&#39;1&#39;, &#39;0&#39;); \nmyGraph.addEdge(&#39;0&#39;, &#39;2&#39;); \nmyGraph.addEdge(&#39;6&#39;, &#39;5&#39;);\n\nmyGraph.showConnections(); \n\n"
} ,
  
  {
    "title"    : "오답노트",
    "category" : "",
    "tags"     : " StudyNote, Incorrects",
    "url"      : "/2020/03/25/Incorrected-Problems.html",
    "date"     : "March 25, 2020",
    "excerpt"  : "이 페이지의 목적\n\n틀렸던 코딩 문제들의 모음집\n\n\n\nProblem : getHeights, Binary search Trees\n\nhttps://www.hackerrank.com/challenges/30-binary-search-trees/problem\n\n스스로 생각했던 풀이 방법\n\n-Node객체를 리턴하는 메소드로 search하고 마지막 가지를 지워가는 형식. 한쪽 줄기를 모두 null로 만들고 돌아오면 count를 max값과 확인하고 ...",
  "content"  : "이 페이지의 목적\n\n틀렸던 코딩 문제들의 모음집\n\n\n\nProblem : getHeights, Binary search Trees\n\nhttps://www.hackerrank.com/challenges/30-binary-search-trees/problem\n\n스스로 생각했던 풀이 방법\n\n-Node객체를 리턴하는 메소드로 search하고 마지막 가지를 지워가는 형식. 한쪽 줄기를 모두 null로 만들고 돌아오면 count를 max값과 확인하고 초기화하고 다시 다른 줄기로 가는 형식 그렇게 반복해서 root가 null이면 count를 하나 더하고 종료 -&amp;gt; 이 때 count를 search과정에서 받아야하는데 return값이 하나이므로 불가능. class변수로 두면 되지만 기존에 주어진 Node의 root객체로 다시 돌아오기가 힘듦.\n\n-아니면 자신을 recursion해서 Node를 스스로 갱신해가면서 똑같은 방식을 하는 방법 -&amp;gt; 기본적으로 주어진 method가 int라 불가, 가지 node를 지우고 다시 root로 돌아오기가 불가능.\n\n-입력되는 숫자의 갯수를 이용해서 log를 계산한 후 가장 마지막에 있을 가지들의 갯수를 계산해 for문의 반복수를 제한하여 가지들을 한번씩 들르고 돌아오는 방법\n\n정답\n\npublic static int getHeight(Node root){\n    if (root == null){\n        return -1;\n    }\n    else{\n        return 1 + Math.max( getHeight(root.left), getHeight(root.right) );\n    }\n}\n\n\n양 옆의 가지가 비어있을 때 까지 recursion하고 빈 곳에서 -1을 받고 그 위로 0를 리턴한다. 이렇게 되면 양쪽 중 긴쪽의 return값이 더 크기 때문에 큰 값만 return되고 최종적으로 가장 큰 값만 return되어 가장 큰 길이를 얻을 수 있다.\n\n복습 노트 (직접 구현하면서 복습했던 것들)\n\nBFS, DFS 다시\n\n반성 노트\n\n퀵소트도 못했던 이유\n\n  \n    스스로 어느정도까지 범위를 줘야하는지도 헷갈리고 있었다.(for문 범위나 array범위를 정확히 몰라서 에러가 나고 이게 혼돈의 카오스)\n\n    = 기본도 안되어 있었다.\n  \n  \n    모든걸 한꺼번에 하려 했다.(이번엔 divide기능 먼저 확실하게 하고 기능을 하나씩 추가해가면서 만들었다.)\n  \n\n\n2-1. 이번엔 기능을 한번에 하나씩 추가했다.\n\n2-2. 이번엔 해야하는 일(논리구조)을 쪼개서 하나씩 만족시켜 나갔다.(divide를 연속으로 실행 후 1개가 되었을 때 merge연속시행)\n"
} ,
  
  {
    "title"    : "Recursion",
    "category" : "",
    "tags"     : " ComputerScience, Algorithms",
    "url"      : "/2020/03/24/Recursion.html",
    "date"     : "March 24, 2020",
    "excerpt"  : "Recursion\n\nRecursion은 자신의 알고리즘을 다시 불러와 사용하는 것이다.\n\nRecursion을 통해 똑같은 자신의 function을 call stack에 저장하고 base case에 도달하면\n\npush된 recursion function들을 하나씩 pop하면서 실행한다.\n\n\n\nBig O notation\n\nFibonacci iterrative = O(n)\n\nrecursive = ##O(2^n)## (O(n^2)보다 훨씬 ope...",
  "content"  : "Recursion\n\nRecursion은 자신의 알고리즘을 다시 불러와 사용하는 것이다.\n\nRecursion을 통해 똑같은 자신의 function을 call stack에 저장하고 base case에 도달하면\n\npush된 recursion function들을 하나씩 pop하면서 실행한다.\n\n\n\nBig O notation\n\nFibonacci iterrative = O(n)\n\nrecursive = ##O(2^n)## (O(n^2)보다 훨씬 operation이 많다.)\n\nAlthough!! why they use recursive?\n\n##Anything you can do with a recursion CAN be done iteratively(loop)##\n\n\n  \n    \n      pros\n      cons\n    \n  \n  \n    \n      Readable\n      Need Large Stack\n    \n    \n      DRY\n       \n    \n  \n\n\njavascript 6 version부터는 recursion을 call stack을 늘리지 않고 사용할 수 있다고 한다!!!!(a.k.a Tail call optimization)\n\nhttps://2ality.com/2015/06/tail-call-optimization.html\n\n이러한 기능은 다른 언어에서도 지원한다고 한다.\n\nThen, When we should use the recursion?\n\nEverytime you are using a tree converting Something into a tree, consider Recursion.\n\n\n  Divided into a number of subproblems that are smaller instances of the same problem(문제를 작게 같은 문제들로 쪼갤 수 있다.)\n  Each instance of the subproblem is identical in nature(쪼갠 문제들의 operation이 모두 같다.)\n  The solution of each subproblem can be combined to solve the problem at hand(여러개로 쪼개진 문제들이 모여 문제를 해결 할 수 있다.)\n\n\n정리하면…\n\n\n  Divide and Conquer using Recursion\n  BFS(Breadth First Search), DFS(Depth First Search)\n  Tree Data structure or Tree Traversal\n  Sorting\n\n\nThree Rules\n\n복잡한것 같지만 이 법칙을 가지고 하나씩 생각하며 recursion을 해석하면 쉽다.\n\n\n  Identify the base case\n  Identify the recursive case\n  Get closer and closer and return when needed. Usually you have 2 returns.\n\n\nExplain!\n\nex1\n\nvar counter = 0;\nfunction inception(){\n inception();\n console.log(counter);\n}\n\ninception();\n\n\n이 logic의 결과는 Stack overflow(call stack overflow)이다. 끊임없이 자신을 불러내기만 하고 console.log에 도달하지 못해\n\n아무것도 출력하지 못한다.\n\nex2\n\nvar counter = 0;\nfunction inception(){\n console.log(counter)\n if(counter &amp;gt; 3) {\n  return &quot;done&quot;;\n }\n counter++;\n inception();\n}\n\ninception();\n\n\n이때 inception을 호출했을 경우 결과는 Undefined라는 처리 결과가 나오게 된다.\n\nDebug시에 보면 가장 첫번째는 return을 통해 ‘done’을 출력하지만 recursion으로 불린 function들은 return하지 않기 때문에 Undefined가 출력된다.\n\ninception(inception(‘done’)) = inception(Undefined) …\n\nex3\n\nvar counter = 0;\nfunction inception(){\n console.log(counter)\n if(counter &amp;gt; 3) {\n  return &quot;done&quot;;\n }\n counter++;\n return inception();\n}\n\ninception();\n\n\nRecursion한 method를 return하라고 한다면 자신이 가진 return “done”을 return 하기에 가장 마지막에 pop되는 method에서 return을 실행하여 “done”이 출력된다.\n\ninception(inception(‘done’)) = inception(‘done’) …\n\nExcersise\n\nfactorial\n\nfunction findFactorialIterative(number) {\n  let answer = 1;\n  for (let i = 2; i &amp;lt;= number; i++) {\n    answer = answer * i;\n  }\n  return answer;\n}\n\nfunction findFactorialRecursive(number) {\n  if(number === 2) {\n    return 2;\n  }\n  return number * findFactorialRecursive(number - 1)\n}\n\nfindFactorialIterative(5); //O(n)\nfindFactorialRecursive(5); //O(n)\n\n\nFibonacci\n\nMy answer\n\nfunction fibonacciIterative(n){\n  var result = 0;\n  var foreNum = 0;\n  var beforeNum = 1;\n  if(n===1){\n    return 1;\n  }\n  for(var i = 0; i &amp;lt; n-1; i++){\n    result = foreNum + beforeNum;\n    if(i%2 === 0){\n      foreNum = result;\n    }else{\n      beforeNum = result;\n    }\n  }\n  return result;\n}\nfibonacciIterative(3);\n\nfunction fibonacciRecursive(n) {\n  var beforeNum;\n  if(n === 0 || n === 1){\n    return n;\n  }\n  beforeNum = fibonacciRecursive(n-2);\n  \n  return beforeNum + fibonacciRecursive(n-1);\n}\n\nfibonacciRecursive(8)\n\n\nBetter Answer\n\nfunction fibonacciIterative(n){\n  let arr = [0, 1];\n  for (let i = 2; i &amp;lt; n + 1; i++){\n    arr.push(arr[i - 2] + arr[i -1]);\n  }\n return arr[n];\n}\nfibonacciIterative(3);\n\nfunction fibonacciRecursive(n) {\n  if (n &amp;lt; 2){\n    return n;\n  }\n  return fibonacciRecursive(n - 1) + fibonacciRecursive (n - 2)\n}\n\nfibonacciRecursive(6)\n\n"
} ,
  
  {
    "title"    : "Binary Heaps And Trie",
    "category" : "",
    "tags"     : " ComputerScience, DataStructure",
    "url"      : "/2020/03/22/Binary-Heaps-And-Trie.html",
    "date"     : "March 22, 2020",
    "excerpt"  : "Binary Heaps\n\nTree의 한 종류\n\n규칙 : 위 층보다 작은 숫자가 위치한다. 만약 밑에 부모보다 큰 수가 자식에 오면 자리가 교체된다.\n\n\n\nhttps://visualgo.net/en/heap\n\npriority queue\n\n높은 수가 부모로 간다는 법칙을 통해 우선순위 큐를 구성할 수 있다. heap의 큰 특징이다 장점이라 할 수 있다.\n\n큰 수가 더 높은 우선순위를 가진다고 하면 heap의 법칙에 따라 나중에 추가되엇어도 높...",
  "content"  : "Binary Heaps\n\nTree의 한 종류\n\n규칙 : 위 층보다 작은 숫자가 위치한다. 만약 밑에 부모보다 큰 수가 자식에 오면 자리가 교체된다.\n\n\n\nhttps://visualgo.net/en/heap\n\npriority queue\n\n높은 수가 부모로 간다는 법칙을 통해 우선순위 큐를 구성할 수 있다. heap의 큰 특징이다 장점이라 할 수 있다.\n\n큰 수가 더 높은 우선순위를 가진다고 하면 heap의 법칙에 따라 나중에 추가되엇어도 높은 곳에 추가되고\n\n위에서부터 차례대로 작업을 수행하면서 내려간다면 이것이 곧 우선순위가 주어진 queue와 같은 움직임이라 할 수 있다.\n\nbig O notation\n\n\n  \n    \n      methods\n      big O notation\n    \n  \n  \n    \n      lookup\n      O(N)\n    \n    \n      insert\n      O(log N)\n    \n    \n      (perfect case)\n      O(1)\n    \n    \n      delete\n      O(log N)\n    \n  \n\n\nTrie\n\n\n\nTrie는 보통 text와 함께 쓰이며 searching에 특화된 Tree이다.\n\nsearch의 종류에 따라 hash table이나 binary search tree 등의 여러 data structure들의 search속도를 능가할 수 있다.\n\nSpeed &amp;amp; Space Advantage\n\nSpeed : O(length of word)이지만 문자 A를 찾으면 A와 관련된 아래의 Are이나 As를 한번에 찾을 수 있다. 따라서 검색속도가 매우 빠르다.\n\nSpace : 단어 하나하나 Are따로 As따로 저장 할 필요없이 A를 저장하고 관련된 문자들을 연결해놓으면 되기 때문에 저장공간이 매우 절약된다.(한마디로 prefix를 사용하면 된다.)\n\nMemory heap And Heap\n\nThey have the same name but they really aren’t similar (even conceptually). A memory heap is called a heap in the same way you would refer to a laundry basket as a “heap of clothes”.\n\nThis name is used to indicate a somewhat messy place where memory can be allocated and deallocated at will. The data structure (as the Wikipedia link you reference points out) is quite different.\n\nhttps://stackoverflow.com/questions/1699057/why-are-two-different-concepts-both-called-heap\n"
} ,
  
  {
    "title"    : "Algorithms",
    "category" : "",
    "tags"     : " ComputerScience, Algorithms",
    "url"      : "/2020/03/22/Algorithms.html",
    "date"     : "March 22, 2020",
    "excerpt"  : "Algorithms\n\nAlgorithm이란 간단히 process들의 step으로 computer에게 우리가 원하는 동작을 명령하는 것이다.\n\nData Structures + Algorithms = Programs\n\n위 수식에서 Algorithm은 Data structure를 이용해 특정 동작을 할 수 있게 해준다.\n\n\n\nWhy Algorithms are so important, especially in big company?\n\n큰 기업에서...",
  "content"  : "Algorithms\n\nAlgorithm이란 간단히 process들의 step으로 computer에게 우리가 원하는 동작을 명령하는 것이다.\n\nData Structures + Algorithms = Programs\n\n위 수식에서 Algorithm은 Data structure를 이용해 특정 동작을 할 수 있게 해준다.\n\n\n\nWhy Algorithms are so important, especially in big company?\n\n큰 기업에서는 다루는  데이터의 양이 어마어마하기 때문에 조금의 Big O notation의 차이가 큰 속도의 차이를 만들어낸다.\n\n특히 Algorithm을 통해서 Data structure의 속도의 한계를 극복할 수도 있기 때문에 매우 중요하다.\n"
} ,
  
  {
    "title"    : "Trees",
    "category" : "",
    "tags"     : " ComputerScience, DataStructure",
    "url"      : "/2020/03/20/Trees.html",
    "date"     : "March 20, 2020",
    "excerpt"  : "Trees\n\nParent Child 관계를 가진 데이터 구조로 Root Directory로 부터 내려간다.\n\nRules\n\n\n  모든 Parent node는 최대 2개의 child를 가질 수 있다.\n  Parent node보다 좌측의 node는 Parent보다 항상 작다.\n  Parent node보다 우측의 node는 Parent보다 항상 크다.\n\n\n대표적인 예가 바로 윈도우의 파일 구조이다.\n\n\n\nTree Terminology\n\n\n  Ro...",
  "content"  : "Trees\n\nParent Child 관계를 가진 데이터 구조로 Root Directory로 부터 내려간다.\n\nRules\n\n\n  모든 Parent node는 최대 2개의 child를 가질 수 있다.\n  Parent node보다 좌측의 node는 Parent보다 항상 작다.\n  Parent node보다 우측의 node는 Parent보다 항상 크다.\n\n\n대표적인 예가 바로 윈도우의 파일 구조이다.\n\n\n\nTree Terminology\n\n\n  Root : Tree의 가장 Top\n  Child : 다른 node와 직접적으로 연결 된 node, 부모의 하위 개념이 된다.\n  Parent : Child의 부모\n  Siblings : 같은 부모를 가진 다른 Child node\n  Leaf : Children이 없는 node\n  Edge : 어떤 node와 다른 node의 연결\n\n\nKinds of Trees\n\n\n  Trees\n  Binary Trees\n  Binary Search Trees\n\n\nbig O notation\n\n\n  \n    \n      methods\n      big O notation\n    \n  \n  \n    \n      insert\n      O(log N)\n    \n    \n      search\n      O(log N)\n    \n    \n      delete\n      O(log N)\n    \n  \n\n\npros &amp;amp; cons\n\n\n  \n    \n      pros\n      cons\n    \n  \n  \n    \n      Better than O(n)\n      No O(1) Operation\n    \n    \n      Ordered\n       \n    \n    \n      Flexible size\n       \n    \n  \n\n\nExamples\n\n\n  HTML DOM(Document Object Model)\n  Network Routing\n  abstract syntax tree\n  AI(경우의 수 판단, 분석 시)\n  OS’s Folder System\n\n\nUnbalanced Binary Search Tree(!!!)\n\n\n\n제대로 정렬되있지 않은 tree는 이런식으로 길게 늘어져 linked list와 같은 형태를 가지게 된다.\n\n해결하는 방법은 길쭉한 line의 가운데 값을 root로 삼아 양 옆으로 데이터를 분산 하는 방법이다.\n\nreference(AVL과 Red,Black의 작동원리를 애니메이션)\n\nhttps://www.cs.usfca.edu/~galles/visualization/AVLtree.html\n\nhttps://www.cs.usfca.edu/~galles/visualization/RedBlack.html\n\nRed/Black tree, AVL tree\n\n이 두가지 tree Data structure는 너무 치우쳐 있다면 알아서 balance를 잡을 수 있도록 해주는 tree로서 tree가 길게 늘어지지 않게 한다.\n\n3개가 한줄로 이루어져 있을 때, 그 가운데 값을 root로 두고 나머지를 양 옆으로 분산하여 tree구조의 balace를 맞춘다.\n"
} ,
  
  {
    "title"    : "Doubly Linked Lists",
    "category" : "",
    "tags"     : " ComputerScience, DataStructure",
    "url"      : "/2020/03/10/Doubly-Linked-Lists.html",
    "date"     : "March 10, 2020",
    "excerpt"  : "Doubly Linked List\n\nSingle Linked List와는 다르게 Pointer가 2개이다. 다음 Data를 가리키는 pointer, 그 전 Data를 가리키는 pointer가 그것이다.\n\npointer가 하나 더 있기 때문에 Memory가 2배로 소모되지만 더 flex하게 Data를 다룰 수 있다.(특히 앞에서만 시작했던 linked list와는 달리 뒤에서도 접근이 가능하다.)\n\n웹페이지 forward, backward가...",
  "content"  : "Doubly Linked List\n\nSingle Linked List와는 다르게 Pointer가 2개이다. 다음 Data를 가리키는 pointer, 그 전 Data를 가리키는 pointer가 그것이다.\n\npointer가 하나 더 있기 때문에 Memory가 2배로 소모되지만 더 flex하게 Data를 다룰 수 있다.(특히 앞에서만 시작했던 linked list와는 달리 뒤에서도 접근이 가능하다.)\n\n웹페이지 forward, backward가 이것으로 구성되어 있다.\n\n\n\nMethods\n\n\n  \n    \n      methods\n      Big O notation\n    \n  \n  \n    \n      Inserts\n      O(1)\n    \n    \n      Removal\n      O(1)\n    \n    \n      Searching\n      O(n)\n    \n    \n      Access\n      O(n)\n    \n  \n\n\n물론 실제로는 searching, access는 O(n/2)지만 규칙에 따라 O(n)이다.\n\nreference\n\nhttps://visualgo.net/en/list?slide=1a\n\nMy codes (Javascript)\n\nclass Node{\n    constructor(val){\n        this.val = val;\n        this.next = null;\n        this.prev = null;\n    }\n}\n\nclass DoublyLinkedList {\n    constructor(){\n        this.head = null;\n        this.tail = null;\n        this.length = 0;\n    }\n    push(val){\n        var newNode = new Node(val);\n        if(this.length === 0){\n            this.head = newNode;\n            this.tail = newNode;\n        } else {\n            this.tail.next = newNode;\n            newNode.prev = this.tail;\n            this.tail = newNode;\n        }\n        this.length++;\n        return this;\n    } \n    pop(){\n        if(!this.head) return undefined;\n        var poppedNode = this.tail;\n        if(this.length === 1){\n            this.head = null;\n            this.tail = null;\n        } else {\n            this.tail = poppedNode.prev;\n            this.tail.next = null;\n            poppedNode.prev = null;\n        }\n        this.length--;\n        return poppedNode;\n    }\n    shift(){\n        if(this.length === 0) return undefined;\n        var oldHead = this.head;\n        if(this.length === 1){\n            this.head = null;\n            this.tail = null;\n        }else{\n            this.head = oldHead.next;\n            this.head.prev = null;\n            oldHead.next = null;\n        }\n        this.length--;\n        return oldHead;\n    }\n    unshift(val){\n        var newNode = new Node(val);\n        if(this.length === 0) {\n            this.head = newNode;\n            this.tail = newNode;\n        } else {\n            this.head.prev = newNode;\n            newNode.next = this.head;\n            this.head = newNode;\n        }\n        this.length++;\n        return this;\n    }\n    get(index){\n        if(index &amp;lt; 0 || index &amp;gt;= this.length) return null;\n        var count, current;\n        if(index &amp;lt;= this.length/2){\n            count = 0;\n            current = this.head;\n            while(count !== index){\n                current = current.next;\n                count++;\n            }\n        } else {\n            count = this.length - 1;\n            current = this.tail;\n            while(count !== index){\n                current = current.prev;\n                count--;\n            }\n        }\n        return current;\n    }\n    set(index, val){\n        var foundNode = this.get(index);\n        if(foundNode != null){\n            foundNode.val = val;\n            return true;\n        }\n        return false;\n    }\n    insert(index, val){\n      if(index &amp;lt; 0||index &amp;gt;= this.length){\n        return undefinded;\n      }\n      if(index === 0){\n        return this.unshift(val);\n      }\n      if(index === this.length){\n        return this.push(val);\n      }\n      var newNode = new Node(val);\n      var foundNode = this.get(index-1);\n      var nextNode = foundNode.next;\n      foundNode.next = newNode;\n      nextNode.prev = newNode;\n      newNode.next = nextNode;\n      newNode.prev = foundNode;\n      this.length++;\n      return this;\n    }\n    remove(index){\n      if(index &amp;lt; 0||index &amp;gt;= this.length){\n        return undefinded;\n      }\n      if(index === 0){\n        return this.shift();\n      }\n      if(index === this.length-1){\n        return this.pop();\n      }\n      var foundNode = this.get(index);\n      var nextNode = foundNode.next;\n      var prevNode = foundNode.prev;\n      nextNode.prev = prevNode;\n      prevNode.next = nextNode;\n      foundNode = null;\n      this.length--;\n      return foundNode;\n    }\n}\n\n"
} ,
  
  {
    "title"    : "Regular Expression",
    "category" : "",
    "tags"     : " Java, APIs",
    "url"      : "/2020/03/09/Regular-Expression.html",
    "date"     : "March 9, 2020",
    "excerpt"  : "Regular Expression\n\n정규 표현식 또는 정규식은 특정한 규칙을 가진 문자열의 집합을 표현하는 데 사용하는 형식 언어이다. 정규 표현식은 많은 텍스트 편집기와 프로그래밍 언어에서 문자열의 검색과 치환을 위해 지원하고 있으며, 특히 펄과 Tcl은 언어 자체에 강력한 정규 표현식을 구현하고 있다.\n\n\n\nMeta word\n\n정규표현식에서 일정한 의미를 가지고 쓰는 특수문자를 메타 문자라고 부른다. 여기에 쓰이는 글자가 포함된 패턴을...",
  "content"  : "Regular Expression\n\n정규 표현식 또는 정규식은 특정한 규칙을 가진 문자열의 집합을 표현하는 데 사용하는 형식 언어이다. 정규 표현식은 많은 텍스트 편집기와 프로그래밍 언어에서 문자열의 검색과 치환을 위해 지원하고 있으며, 특히 펄과 Tcl은 언어 자체에 강력한 정규 표현식을 구현하고 있다.\n\n\n\nMeta word\n\n정규표현식에서 일정한 의미를 가지고 쓰는 특수문자를 메타 문자라고 부른다. 여기에 쓰이는 글자가 포함된 패턴을 넣으려면 해당 글자 앞에 \\를 넣어줘야 한다.\n\n\n  ^ : 문자열의 시작\n  $ : 문자열의 종료. 옵션에 따라 문장의 끝 또는 문서의 끝에 매치된다.\n  . : 임의의 한 문자\n  []: 문자 클래스. 문자 클래스 안에 들어가 있는 문자는 그 바깥에서 하나의 문자로 취급된다.\n  ^ : 문자 클래스 내에서 ^는 not\n  \n    \n      : ex) a-z는 a에서 z까지의 문자\n    \n  \n  \n    \n      \n        \n          : or를 나타냄\n        \n      \n    \n  \n  ? : 앞 문자가 없거나 하나 있음\n  \n    \n      : 앞 문자가 하나 이상임\n    \n  \n  \n    \n      : 앞 문자가 0개 이상임\n    \n  \n  {n,m} : 앞 패턴이 n개 이상 m개 이하. {0,1} 은 ?와 같은 의미다.\n  {n,} : 앞 패턴이 n개 이상. 위의 형태에서 m이 생략된 형태이다. {0,} 이면 *와 같고 {1,} 이면 +와 같은 의미이다.\n  {n} : 앞 패턴이 정확히 n개. {n,n} 과 같은 의미이다.\n  () : 패턴 그룹. 하나의 패턴구분자 안에 서브 패턴을 지정해서 사용할 경우 괄호로 묶어주는 방식을 사용한다.\n  \\s : 공백문자. 대문자로(\\S) 적으면 반대를 의미한다.\n  \\b : 문자와 공백 사이를 의미한다. 공백, 탭, 컴마, 대시 등이 올 수 있다. 대문자로(\\B) 적으면 반대를 의미한다. (ex) \\bplay\\b일때 playground(x) let’s play around(o) )\n  \\d : 숫자 [0-9]와 같다. 대문자로(\\D) 적으면 반대를 의미한다.\n  \\t : 탭문자\n  \\w : 단어 영문자+숫자+(밑줄) [0-9a-zA-Z] 대문자로(\\W) 적으면 반대를 의미한다.\n\n\n패턴 변경자\n\n패턴구분자가 끝나면 그 뒤에 쓰는 것으로, 패턴에 일괄적으로 변경을 가할 때 사용한다. 정규식 엔진에 따라 변경자의 적용 방식이 상이하므로 해당 구현의 매뉴얼을 읽어야 한다.\n\n예를 들어 대소문자 무시 플래그의 경우 자바스크립트는 /패턴/i 로 쓰지만 파이썬에서는 re.compile(패턴, flags=re.I) 로 Go에서는 (?i)패턴으로 쓴다.\n\n\n  i : 패턴을 대소문자 구분 없이 검사한다. 이 변경자를 사용할 경우 [a-z]로만 검사해도 자동으로 [a-zA-Z]와 같은 기능을 하게 된다. 영어가 아닌 언어(독일어, 프랑스어 등)를 다룰 때에는 버그 가능성이 있으므로 쓰지 않는 게 좋다. 대소문자라는 개념이 없는 한글, 한자, 가나문자는 이 패턴 변경자가 아무 역할도 하지 않는다.\n  s : 임의의 한 문자를 가리키는 . 메타 문자에 개행 문자(\\n)도 포함시키도록 한다. 이 변경자를 사용하면 .이 줄바꿈도 임의의 한 문자로 취급하여 찾는다.\n  g : ^문자가 문장이 아닌 문서의 처음에, $ 문자가 문장의 끝(라인 피드 \\n)이 아닌 주어진 문자열의 끝에 매치되게 변경한다.\n  m : 주어진 문자열에 줄바꿈이 있을 경우, 여러 줄로 취급하여 검사한다. (줄바꿈이 없다면 써도 의미가 없다.) 원래 정규표현식을 쓸 때 줄바꿈은 무시되는데, 이걸 사용하면 줄바꿈을 적용해서 검사한다. 그리고 ^은 한 줄의 시작, $는 한 줄의 끝으로 의미가 달라진다.\n  x : 공백 문자를 무시한다. 단, 이스케이프(역슬래쉬하고 같이 쓸 경우)하거나 문자 클래스 안에 있을 경우에는 예외. 정규식을 조금 더 읽기 편하게 만들어준다. 그러나 이 변경자를 지원하지 않는 엔진이 많은 게 단점이다.\n\n\n탐욕적 및 게으른 수량자\n\n정규표현식에서는 일치하는 패턴을 찾는 횟수제한이 없어 필요이상의 상황을 연출하기도 하는데 이것은 의도적으로 수량자를 탐욕적으로 만들었기 때문이다.\n\n문법에서 말하는 탐욕적 수량자란 가능하면 가장 큰 덩어리를 찾는다는 뜻이며, 반대의 개념인 게으른 수량자(Lazy Quantifier)는 패턴에 근접하는 최소한의 덩어리를 찾는다.\n\n사용 예(Python)\n\n&amp;gt;&amp;gt;&amp;gt; data = &quot;&amp;lt;div&amp;gt; &amp;lt;p&amp;gt;First&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;Second&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;&quot;\n&amp;gt;&amp;gt;&amp;gt; import re\n&amp;gt;&amp;gt;&amp;gt; re.findall(r&quot;&amp;lt;p&amp;gt;(.+)&amp;lt;/p&amp;gt;&quot;, data)  # 기본적으로 탐욕적인 매칭\n[&#39;First&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;Second&#39;]\n&amp;gt;&amp;gt;&amp;gt; re.findall(r&quot;&amp;lt;p&amp;gt;(.+?)&amp;lt;/p&amp;gt;&quot;, data)  # 게으른 수량자 사용\n[&#39;First&#39;, &#39;Second&#39;]\n\n\nIP Regex\n\nIPv4\n\n\n  \n    \n      /^(([0-9]\n      [1-9][0-9]\n      1[0-9]{2}\n      2[0-4][0-9]\n      25[0-5]).){3}([0-9]\n      [1-9][0-9]\n      1[0-9]{2}\n      2[0-4][0-9]\n      25[0-5])$/\n    \n  \n\n\nreference\n\nhttps://regexone.com/\n\nhttps://regexr.com/\n\nexplain\n\nhttps://namu.wiki/w/%EC%A0%95%EA%B7%9C%20%ED%91%9C%ED%98%84%EC%8B%9D?from=%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D\n\nhttps://soooprmx.com/archives/7718\n\nJava Patterns and Matchers methods\n\njava에선 주로 patterns와 matchers클래스로 정규표현식을 다룬다. String.replaceAll(regex, replace)같은 예외도 존재한다.\n\nMatcher 클래스 메서드들\n\nfind() : 패턴이 일치하는 경우 true를 반환하고, 그 위치로 이동(여러개가 매칭되는 경우 반복 실행가능)\nfind(int start) : start위치 이후부터 매칭검색을 수행\nstart() : 매칭되는 문자열 시작위치 반환\nstart(int group) : 지정된 그룹이 매칭되는 시작위치 반환\nend() : 매칭되는  문자열 끝 다음 문자위치 반환\nend(int group) : 지정되 그룹이 매칭되는 끝 다음 문자위치 반환\n\ngroup() : 매칭된 부분을 반환\ngroup(int group) : 매칭된 부분중 group번 그룹핑 매칭부분 반환\ngroupCount() : 패턴내 그룹핑한(괄호지정) 전체 갯수 반환\nmatches() : 패턴이 전체 문자열과 일치할 경우 true 반환\n\nGroup\n\n패턴 내에서 그룹을 지정하기 위해서 ()를 통해 그룹을 설정해주면 되고, () 갯수만큼 그룹이 만들어 진다.\n\n\n\n위 예제에서는 2개의 그룹이 설정이 되었으며, 각 그룹은 group()메서드를 통해 1,2번으로 접근이 가능하다.\n\ngroup()나 group(0) 메서드는 매칭된 전체 문자열을 반환한다.\n\nmatching index\n\nstart()메서드를 통해 패턴이 일치하는 문자열의 시작 위치와 end() 메서드를 통해 패턴이 끝나는 문자열의 다음 문자위치를 반환한다.\n\n\n\nend() 메서드가 패턴이 일치하는 문자열의 끝부분 위치가 아닌 끝부분 다음 문자의 위치이다.\n\nstart(int group)와 end(int group)에 group이 지정되는 경우 해당 그룹이 매칭되는 위치를 반환하게 된다.\n\nhttps://enterkey.tistory.com/353\n"
} ,
  
  {
    "title"    : "Stacks and Queue",
    "category" : "",
    "tags"     : " ComputerScience, DataStructure",
    "url"      : "/2020/03/05/Stacks-and-Queues.html",
    "date"     : "March 5, 2020",
    "excerpt"  : "Stack and Queue\n\n이 둘은 linear data structure로 모든 데이터의 접근과 동작을 순차적으로 해야 하는 특징이 있다.\n\nstack은 선입후출(First In Last Out) Queue는 선입선출(First In First Out)이라는  특징이 있다.\n\n\n\n사용하는 이유\n\n이 두 데이터 구조는 가장 적고 간단한 동작(push, pop)들로만 조작이 가능한데 이는 computer science에서는 중요한 역할을...",
  "content"  : "Stack and Queue\n\n이 둘은 linear data structure로 모든 데이터의 접근과 동작을 순차적으로 해야 하는 특징이 있다.\n\nstack은 선입후출(First In Last Out) Queue는 선입선출(First In First Out)이라는  특징이 있다.\n\n\n\n사용하는 이유\n\n이 두 데이터 구조는 가장 적고 간단한 동작(push, pop)들로만 조작이 가능한데 이는 computer science에서는 중요한 역할을 한다.\n\n이유는 동작이 적고 간단하기 때문에 범용성이 크기 때문이다.\n\n사용 예\n\nstack은 가장 최근에 저장한 정보를 알기에 가장 좋은 데이터 구조이다.\n\n\n  undo, redo = 뒤로가기, 앞으로 가기\n  대부분의 프로그래밍 언어는 stack 방식을 기본으로 하고 있다.\n\n\nqueue는 실생활에서도 많이 쓰이는 데이터 구조 방식이다.\n\n\n  restaurant의 순서\n  롤러코스터의 wating line\n  Uber!\n  printer queue\n  etc…\n\n\nMethods\n\n여기서 헷갈리기 쉬운 점은 peek는 가장 먼저 나올 수 있는 데이터를 보여달라는 method이다.\n\n따라서 stack에서는 가장 최신, queue에서는 가장 최후의 데이터를 보여준다.\n\nstack\n\n\n  \n    \n      methods\n      Big O notation\n    \n  \n  \n    \n      Lookup\n      O(n)\n    \n    \n      pop\n      O(1)\n    \n    \n      push\n      O(1)\n    \n    \n      peek\n      O(1)\n    \n  \n\n\nQueue\n\n\n  \n    \n      methods\n      Big O notation\n    \n  \n  \n    \n      Lookup\n      O(n)\n    \n    \n      enqueue\n      O(1)\n    \n    \n      dequeue\n      O(1)\n    \n    \n      peek\n      O(1)\n    \n  \n\n\nQueue와 Array는 비슷하지만 Array는 index가 있어서 insert나 delete시에 모든 index에 영향을 주기 때문에\n\nQueue에 비해 속도에서 크게 손해를 보게 된다.\n\nPros &amp;amp; Cons\n\n\n  \n    \n      Pros\n      Cons\n    \n  \n  \n    \n      Fast Lookups\n      Slow Lookups\n    \n    \n      Fast peeks\n       \n    \n    \n      Ordered\n       \n    \n  \n\n"
} ,
  
  {
    "title"    : "About JavaScript",
    "category" : "",
    "tags"     : " Tech, Javascript",
    "url"      : "/2020/03/05/About-JavaScript.html",
    "date"     : "March 5, 2020",
    "excerpt"  : "JavaScript\n\njavascript란 single thread 이고 non-blocked 언어이다.\n\n\n\nProgram이란?\n\n\n  Allocate Memory\n  parse and execute(=read and run command)\n\n\nweb browser &amp;amp; javascript engine\n\n각 web browser는 각자의 javascript engine이 있고 chrome은 V8 engine을 사용한다.\n\nEngin...",
  "content"  : "JavaScript\n\njavascript란 single thread 이고 non-blocked 언어이다.\n\n\n\nProgram이란?\n\n\n  Allocate Memory\n  parse and execute(=read and run command)\n\n\nweb browser &amp;amp; javascript engine\n\n각 web browser는 각자의 javascript engine이 있고 chrome은 V8 engine을 사용한다.\n\nEngine은 ‘Memory heap’과 ‘Call stack’으로 이루어져있다.\n\n‘Memory heap’은 데이터가 저장되는 곳=, ‘Call stack’은 code가 read, execute되는 곳이다.\n\nMemory leak\n\n사용하지 않는, 그래서 쓸모없게 된 variable이 있을 때 Memory leak라고 한다.\n\n특히 전역변수는 생성하면 프로그램이 끝날때까지 Memory heap을 차지하기 때문에 memory leak의 원인이 되어 좋지 않다.\n\nCall stack\n\n명령을 stack에 push하고 실행하고 pop하는 형식으로 명령을 계속 실행해 나간다.\n\nSingle Threaded\n\nSingle Thread = one Call stack 이라는 말로 한번에 하나의 명령을 수행한다.\n\nDeadlock &amp;amp; multi thread\n\nmulti thread의 단점으로 Deadlock을 들 수 있다. 복잡하게 여려 명령을 쪼개서 실행하기 때문이다.\n\nStack Overflow\n\n말 그대로 Stack의 용량보다 더 많은 양의 Data혹은 command가 stack에 들어올 때 생기는 오류이다.\n\nStack Overflow는 이런식으로 일으킬 수 있다.\n\nfunction foo(){\n\tfoo()\n}\n\nfoo()\n\n\nRecursion을 통해 foo()가 무한히 stack에 쌓여 overflow가 일어난다.\n\nnon-blocking &amp;amp; asynchronous\n\njavascript는 single thread이 하고 있는 작업을 막지 않는(non-blocking) asynchronous한 언어이다.\n\nsynchronous vs asynchronous\n\nsynchronous는 선생님에게 전화하는것과 같다. 답변을 받기 위해 계속 전화하고 그동안 아무것도 하지 못하는 상태이다.\n\n즉, 맡은 작업이 끝날 때 까지 다른 작업이 방해하지 못하게(blocked)하는 것이다.\n\nasynchronous는 선생님에게 문자를 보내는 것과 같다. 질문을 보내놓고 다른걸 하다가 답변을 받으면 그것을 보고 해결하면 된다.\n\n즉, 맡은 작업이 끝나지 않아도 잠시 미뤄두고 다른 작업을 할 수 있다는 것이다.(non-blocked)(callback)\n\nsetTimeout이 아주 그 예이다. web API중 하나로 특정 시간동안 특정 method를 미뤄뒀다가 callback하여 다시 작업을 처리 할 수 있다.\n\nex) EventLoop, onClick, onLoad etc…\n\nEventLoop\n\nEventLoop는 call stack이 비어있을 때, 남은 작업을 callback 해주는 loop로 callback queue를 하나씩 차례대로 callback해준다.\n\nMy Stack\n\nclass Node {\n\tString value;\n\tNode next;\n\n\tpublic Node(String a) {\n\t\tthis.value = a;\n\t\tthis.next = null;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn &quot;Node [value=&quot; + value + &quot;, next=&quot; + next + &quot;]&quot;;\n\t}\n\t\n}\n\npublic class Stack {\n\n\tString top;\n\tString bottom;\n\tint length;\n\t\n\tpublic Stack() {\n\t\tthis.top = null;\n\t\tthis.bottom = null;\n\t\tthis.length = 0;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tStack stack = new Stack();\n\t\tNode head = new Node(null);\n\t\tString youtube = &quot;youtube&quot;;\n\t\tString google = &quot;google&quot;;\n\t\tString udemy = &quot;udemy&quot;;\n\t\thead = stack.push(youtube, head);\n\t\tstack.peek(head);\n\t\thead = stack.push(google, head);\n\t\tstack.peek(head);\n\t\thead = stack.push(udemy, head);\n\t\tstack.peek(head);\n\t\tstack.pop(head);\n\t\tstack.peek(head);\n\t\tstack.pop(head);\n\t\tstack.peek(head);\n\t\tstack.pop(head);\n\t\tstack.peek(head);\n\t\tstack.pop(head);\n\t}\n\t\n\tvoid peek(Node node){\n\t\t//값이 없다면\n\t\tif(node.value == null) {\n\t\t\tSystem.out.println(&quot;nothing to peek man...&quot;);\n\t\t\tSystem.out.println();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tNode currentNode = node;\n\t\t\n\t\t//최종 값까지 가서\n\t\twhile(currentNode.next != null) {\n\t\t\tcurrentNode = currentNode.next;\n\t\t}\n\t\t\n\t\t//최종 값 출력\n\t\tSystem.out.println(currentNode.value);\n\t\tSystem.out.println();\n\t}\n\t\n\tNode push(String value, Node node) {\n\t\t//최초라면\n\t\tif(node.value == null) {\n\t\t\treturn new Node(value);\n\t\t}\n\t\t\n\t\tNode currentNode = node;\n\t\twhile(currentNode.next != null) {\n\t\t\tcurrentNode = currentNode.next;\n\t\t}\n\t\t\n\t\tcurrentNode.next = new Node(value);\n\t\tlength++;\n\t\t\n\t\treturn node;\n\t}\n\t\n\tNode pop(Node node) {\n\t\t//값이 없다면\n\t\tif(node.value == null) {\n\t\t\tSystem.out.println(&quot;nothing to pop...&quot;);\n\t\t}\n\t\t\n\t\t//마지막 값만 남아 있다면\n\t\tif(node.next == null) {\n\t\t\tnode.value = null;\n\t\t\tlength--;\n\t\t\treturn node;\n\t\t}\n\t\t\n\t\tNode currentNode = node;\n\t\t//최종 바로 전 값까지 가서\n\t\tfor (int i = 1; i &amp;lt; length; i++) {\n\t\t\tcurrentNode = currentNode.next;\n\t\t}\n\t\t\n\t\t//pointer를 제거한다\n\t\tcurrentNode.next = null;\n\t\tlength--;\n\t\t\n\t\treturn node;\n\t}\n}\n\n\n"
} ,
  
  {
    "title"    : "Scope",
    "category" : "",
    "tags"     : " Tech, Java",
    "url"      : "/2020/03/04/Scope.html",
    "date"     : "March 4, 2020",
    "excerpt"  : "Scope\n\nScope(유효범위)란 특정 변수가 적용되는 범위를 뜻하는 개념으로\n\n프로그램이 커지면 여러 가지 이유로 변수 등의 이름이 충돌하게 되는데, 이를 해결하기 위해서 고안된 것이 유효범위라는 개념이다.\n\n\n\nStatic Scope(정적 스코프)\n\n정의 : 사용되는 시점에서의 유효범위를 사용하는 것이 아니라 정의된 시점에서의 유효범위를 사용하는 것이다.\n\nLexical Scope(렉시컬 스코프)라고도 한다.\n\npublic class...",
  "content"  : "Scope\n\nScope(유효범위)란 특정 변수가 적용되는 범위를 뜻하는 개념으로\n\n프로그램이 커지면 여러 가지 이유로 변수 등의 이름이 충돌하게 되는데, 이를 해결하기 위해서 고안된 것이 유효범위라는 개념이다.\n\n\n\nStatic Scope(정적 스코프)\n\n정의 : 사용되는 시점에서의 유효범위를 사용하는 것이 아니라 정의된 시점에서의 유효범위를 사용하는 것이다.\n\nLexical Scope(렉시컬 스코프)라고도 한다.\n\npublic class ScopeDemo {\n    static int i = 5;\n \n    static void a() {\n        int i = 10;\n        b();\n    }\n \n    static void b() {\n        System.out.println(i);\n    }\n \n    public static void main(String[] args) {\n        a();\n    }\n \n}\n\n\n위의 로직에서 메소드 a가 메소드 b를 호출하고 있는데 메소드 b에는 변수 i의 값이 존재하지 않는다.\n\n이 상태에서 메소드 a를 호출하면 메소드 b에서 System.out.println(i)를 했을 때 메소드 a의 변수 i가 아닌 클래스 변수 i를 사용한다.\n\n메소드 내(b)에서 지역변수가 존재하지 않는다면 그 메소드가 소속된 클래스의 전역변수를 사용하게 된다는 것이 정적 스코프의 대표적인 예라고 할 수 있다.\n\nDynamic Scope(동적 스코프)\n\n동적 스코프라는 것도 있다. 만약 메소드 b의 결과가 10이라면 메소드 b는 메소드 a의 유효범위에 소속된 것이라고 할 수 있다. 하지만 자바는 동적 스코프를 채택하지 않고 있다.\n\n대부분의 현대적인 언어들이 정적 스코프 방식을 선택하고 있다.\n\nreference\n\nhttps://opentutorials.org/module/516/5447\n"
} ,
  
  {
    "title"    : "Linked Lists",
    "category" : "",
    "tags"     : " ComputerScience, DataStructure",
    "url"      : "/2020/03/03/LinkedLists.html",
    "date"     : "March 3, 2020",
    "excerpt"  : "Linked List\n\nLinked List는 value와 node가 한 세트이며 node는 다음 순서의 value를 가리킨다.\n\n\n\nLinked List vs Arrays\n\n검색시 똑같은 O(n)의 시간 복잡도를 갖지만 Linked List는 random하게 메모리에 저장하고 Array는 데이터 바로 옆에 순서대로 저장하기 때문에\n\n같은 시간복잡도를 갖더라도 Array가 검색에 더 빠르다.\n\nMethods\n\n\n  \n    \n      m...",
  "content"  : "Linked List\n\nLinked List는 value와 node가 한 세트이며 node는 다음 순서의 value를 가리킨다.\n\n\n\nLinked List vs Arrays\n\n검색시 똑같은 O(n)의 시간 복잡도를 갖지만 Linked List는 random하게 메모리에 저장하고 Array는 데이터 바로 옆에 순서대로 저장하기 때문에\n\n같은 시간복잡도를 갖더라도 Array가 검색에 더 빠르다.\n\nMethods\n\n\n  \n    \n      methods\n      Big O notation\n    \n  \n  \n    \n      Prepend\n      O(1)\n    \n    \n      Append\n      O(1)\n    \n    \n      Lookup\n      O(n)\n    \n    \n      insert\n      O(n)\n    \n    \n      delete\n      O(n)\n    \n  \n\n\nPrepend와 Append는 head와 tail에 추가하는 것으로 list에 들어가지 않아도 바로 실행 가능하기 때문에 O(1)이다.\n\n나머지 모든 행동은 순서를 따라가서 해당 value에 도착해 동작해야해서 O(n)이다.\n\nPointer\n\nLinked list에는 다른 데이터 구조에는 없는 개념인 Pointer가 있다. 하나의 node가 다른 node를 가르키는 것의 연속이기 때문이다.\n\npointer는 간단하게 특정 데이터가 있는 곳을 가리키는 reference를 말한다.\n\n우리가 선언하는 객체의 이름도 일종의 pointer로서 해당 객체의 주소값을 담고 있는 것이다. 해당 객체의 주소값을 없애버리면 참조받지 않는 객체 데이터는 garbage collector에 의해 지워진다.\n\nC언어에선 garbage collector의 기능을 사람이 해줘야한다. 이는 잘 다루면 컴퓨터의 효율면에서 성능을 크게 향상 시킬 수 있다.\n"
} ,
  
  {
    "title"    : "Hash Tables",
    "category" : "",
    "tags"     : " ComputerScience, DataStructure",
    "url"      : "/2020/03/02/HashTables.html",
    "date"     : "March 2, 2020",
    "excerpt"  : "Hash Tables\n\n특정 Key에 특정 value가 있는 배열구조형태\n\nHash Table이 중요한 점은 실생활에서도 매우 많이 사용되고 있고 따라서 coding test에 반드시 물어본다는 점에 있다.\n\n그리고 많이 쓰이는 이유는! 보통 HashTable로 처리시간을 크게 단축할 수 있기 때문이다(공간은 더 차지하지만)\n\n\n\nPros &amp;amp; Cons\n\n\n  \n    \n      Pros\n      Cons\n    \n  \n  \n  ...",
  "content"  : "Hash Tables\n\n특정 Key에 특정 value가 있는 배열구조형태\n\nHash Table이 중요한 점은 실생활에서도 매우 많이 사용되고 있고 따라서 coding test에 반드시 물어본다는 점에 있다.\n\n그리고 많이 쓰이는 이유는! 보통 HashTable로 처리시간을 크게 단축할 수 있기 때문이다(공간은 더 차지하지만)\n\n\n\nPros &amp;amp; Cons\n\n\n  \n    \n      Pros\n      Cons\n    \n  \n  \n    \n      Fast Lookups\n      UnOrdered\n    \n    \n      Fast inserts\n      Slow Key Iteration\n    \n    \n      Flexible keys\n      More Space Complexity\n    \n  \n\n\nKey Iteration이 느린 이유는 컴퓨터에 의해 마구잡이로 저장된 Hash들을 메모리 단위에서 모두 찾아가야하기 때문이다.\n\nHash는 key값의 데이터를 저장해야하기 때문에 다른 데이터 구조보다 더 많은 공간을 소모한다.\n\nHash Function\n\n만약 내가 ‘Hello’라고 입력하면 Hash function을 통해 알 수 없는 암호같은 문자로 바뀌는데 이것이 Hash function이다.\n\n중요한점은 입력이 같다면 출력이 같다는 점이고 이러한 특성을 ‘Idempotent’라고 한다.\n\n이것을 사용하는 이유는 1. key값으로 데이터를 유추할 수 없게하여 보안 강화 2. key값을 통해 특정 데이터를 매우 빨리 찾을 수 있다. 는 점이 장점이다.\n\nMethods\n\n\n  \n    \n      methods\n      Big O notation\n    \n  \n  \n    \n      insert\n      O(1)\n    \n    \n      Lookup\n      O(1)\n    \n    \n      delete\n      O(1)\n    \n    \n      search\n      O(1)\n    \n  \n\n\narray에서 처럼 index를 수정할 필요가 없어서 insert와 delete가 O(1)이다.\n\nHash Collisions\n\n같은 key에 1개 이상의 value가 들어왔을때, Hash Collision이라 한다.(일종의 Overflow)\n\nOverflow된 value는 Linked list 형태로 같은 key에 종속되어 저장된다.Seperate chaning\n\n중요한 점은 Overflow가 되면 reading과 writing의 속도가 O(n/k) = O(n)이 된다는 점이다.(k는 key의 갯수이다.)\n\nMap과 Set\n\nMap은 무작위로 저장하는 것이 아닌 순서대로 저장한다.\n\nSet은 value없이 key만 저장한다.\n"
} ,
  
  {
    "title"    : "Arrays",
    "category" : "",
    "tags"     : " ComputerScience, DataStructure",
    "url"      : "/2020/03/01/Arrays.html",
    "date"     : "March 1, 2020",
    "excerpt"  : "Arrays!!\n\n\n\n순차적인 순서를 가진 Array이다.\n\n언제나 명심해야 할 것은 엔지니어로서 한정된 자원을 가장 효율적으로 사용할 수 있도록하여 원하는 목표를 달성하는 것이 목표이기 때문에 데이터 구조(Data Structure)와 이를 구성하는 것들의 속성 또한 함께 알아둬야 한다.\n\n\n\nPros &amp;amp; Cons\n\n\n  \n    \n      Pros\n      Cons\n    \n  \n  \n    \n      Fast Lookup...",
  "content"  : "Arrays!!\n\n\n\n순차적인 순서를 가진 Array이다.\n\n언제나 명심해야 할 것은 엔지니어로서 한정된 자원을 가장 효율적으로 사용할 수 있도록하여 원하는 목표를 달성하는 것이 목표이기 때문에 데이터 구조(Data Structure)와 이를 구성하는 것들의 속성 또한 함께 알아둬야 한다.\n\n\n\nPros &amp;amp; Cons\n\n\n  \n    \n      Pros\n      Cons\n    \n  \n  \n    \n      Fast Lookups\n      Slow Inserts\n    \n    \n      Fast push/pop\n      Slow Deletes\n    \n    \n      Ordered\n      Fixed Size(when static)\n    \n  \n\n\nArray는 index가 특정되어 있어 특정정보를 찾기 좋고 index를 수정안해도 되는 push/pop에 대해서 O(1)로 빠르다.\n\n하지만 Insert Delete에서는 수정후 그 뒤의 데이터들의 index를 모두 수정해줘야하므로 O(n)이고 따라서 느리다.\n\nmethods\n\n\n  \n    \n      methods\n      Big O notation\n    \n  \n  \n    \n      Lookup\n      O(1)\n    \n    \n      push\n      O(1)\n    \n    \n      insert\n      O(n)\n    \n    \n      delete\n      O(n)\n    \n    \n      append\n      O(1) or O(n)\n    \n  \n\n\nappend는 dynamic array에서 사용하는것으로 push와 같으나 자신의 메모리 공간을 확장할 때 O(n)의 과정을 거친다. 특이사항 추가 설명 참고!\n\npush and unshift(배열 가장 처음에 넣기)\n\npush랑 pop은 배열내 데이터들의 주소를 수정해줄 필요가 없지만 unshift같은 배열 가장 처음에 데이터를 추가하는 것은 첫 배열에 데이터를 추가하고 뒤의 나머지 데이터들의 index를 모두 수정해줘야하기 때문에 O(n)의 값을 가진다.\n\ninsert delete\n\n마찬가지로 insert하고 해당 데이터 배열 뒤의 데이터들의 index를 모두 수정해줘야하고 delete도 마찬가지이기 때문에 O(n)의 값을 가진다.\n\nstatic &amp;amp; dynamic array\n\nstatic\n\n정적 array로 정해진 array를 정의해놓고 시작한다. 따라서 최대로 넣을 수 있는 데이터 수가 정해져있다.\n\ndynamic\n\n컴퓨터가 자동으로 array의 공간을 할당하여 array를 만든다. 따라서 데이터를 넣을때마다 array크기를 알아서 조절해준다.\n\n특이 사항\n\ndynamic은 자동으로 메모리 공간을 할당하기 때문에 할당된 메모리 공간보다 더 많은 데이터가 오면\n\n기존의 array를 더 큰 메모리 공간에 copy &amp;amp; paste한 다음 추가 데이터를 집어 넣는다\n\n따라서! static에서 push에 해당하는 append는 O(1)일 수도 있지만 O(n)일 수 도 있다.\n"
} ,
  
  {
    "title"    : "Big O Notation",
    "category" : "",
    "tags"     : " ComputerScience",
    "url"      : "/2020/02/24/Big-O-Notation.html",
    "date"     : "February 24, 2020",
    "excerpt"  : "Which code is Best?\n\n\n\n프로그램의 코드를 평가하는데는 3가지의 관점에서 평가할 수 있다.\n\n1.Readable\n2.Space Complexity\n3.Time Complexity\n\n\n\nReadable\n\n즉 가독성이다. 읽기 쉽고 직관적인 코드는 유지보수에 큰 도움이 되고 프로그램의 수명도 길어진다.\n\nSpace Complexity = Memory\n\n메모리 공간을 얼마나 사용하는 지에 대한 관점이다.\n\n메모리 공간은 한정되있...",
  "content"  : "Which code is Best?\n\n\n\n프로그램의 코드를 평가하는데는 3가지의 관점에서 평가할 수 있다.\n\n1.Readable\n2.Space Complexity\n3.Time Complexity\n\n\n\nReadable\n\n즉 가독성이다. 읽기 쉽고 직관적인 코드는 유지보수에 큰 도움이 되고 프로그램의 수명도 길어진다.\n\nSpace Complexity = Memory\n\n메모리 공간을 얼마나 사용하는 지에 대한 관점이다.\n\n메모리 공간은 한정되있고 그것을 최대한 효율적으로 사용하는 코드일 수록 효율적인 코드이다.\n\nps. Memory의 종류 - heap : 변수와 여러 값들을 직접 저장하는 곳, stack :  where we keep track of our function calls\n\nTime Complexity = Speed\n\n처리 속도에 대한 관점이다.\n\n처리 속도가 빠를 수록 효율적인 코드라 할 수 있다.\n\n위 3가지를 모두 항상 만족할 수 없겠지만 그 타협점에서 가장 효율적인 코드를 완성하는 것을 목표로 해야한다!\n\nBig O Notation\n\n\n\n어떤 처리 과정이 얼마나 효율적인가를 표현하는 코드의 처리 효율성 Index같은 것이다.\n\nDefinition\n\n여러가지 복잡도 표기법중에서는 Big O Notation을 가장 많이 사용한다.\n\nBig O Notation은 밑에 표처럼 여러가지로 구분 될 수 있다.\n\n\n\nRules\n\nBig O Notation으로 복잡도를 판단하는 4가지의 룰이 있다.\n\n1. Worst Case\n\nString [] nemo = {&quot;asd&quot;, &quot;sdf&quot;, &quot;qwe&quot;, &quot;nemo&quot;, &quot;zxc&quot;};\n\nfindNemo(nemo);\n\npublic void findNemo(String []array) {\n\t\tDate date = new Date();\n\t\tlong startD = date.getTime();\n\t\tfor (int i = 0; i &amp;lt; array.length; i++) {\n\t\t\tif (array[i] == &quot;nemo&quot;) {\n\t\t\t\tSystem.out.println(&quot;Found Nemo!!&quot;);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlong endD = date.getTime();\n\t\tSystem.out.println(&quot;Call to find Nemo = &quot; + (endD - startD));\n\t}\n\n\nnemo 배열안에 nemo는 4번째에 있어서 for문을 모두 돌지 않고 4번째에서 멈추기 때문에 복잡도는 4라고 할 수 있지만\n\nNotation은 항상 최대로 for문이 실행되었을 경우를 가정해야 한다. 따라서 O(n)이 된다.\n\n2. Remove Constants\n\npublic void findNemo(String []array) {\n\t\t\n\t\tfor (int i = 0; i &amp;lt; array.length; i++) {\n\t\t\tif (array[i] == &quot;nemo&quot;) {\n\t\t\t\tSystem.out.println(&quot;Found Nemo!!&quot;);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i &amp;lt; array.length; i++) {\n\t\t\tif (array[i] == &quot;nemo&quot;) {\n\t\t\t\tSystem.out.println(&quot;Found Nemo!!&quot;);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\nfor문을 2번 실행하기 때문에 O(2n)이 맞지만 constant는 지워줘야하는 룰에 의해 O(n)이 된다.\n\n3. Different terms for inputs\n\npublic void findNemo(String []array, String []array2) {\n\t\t\n\t\tfor (int i = 0; i &amp;lt; array.length; i++) {\n\t\t\tif (array[i] == &quot;nemo&quot;) {\n\t\t\t\tSystem.out.println(&quot;Found Nemo!!&quot;);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i &amp;lt; array2.length; i++) {\n\t\t\tif (array2[i] == &quot;nemo&quot;) {\n\t\t\t\tSystem.out.println(&quot;Found Nemo!!&quot;);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\n넣어주는 parameter값이 여러개라면 모두 다른 이름으로 넣어주어야한다.\n\n4. Drop Non Dominants\n\npublic void rule4(String []array, String []array2) {\n\t\tfor (int i = 0; i &amp;lt; array.length; i++) {\n\t\t\tif (array[i] == &quot;nemo&quot;) {\n\t\t\t\tSystem.out.println(&quot;Found Nemo!!&quot;);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i &amp;lt; array.length; i++) {\n\t\t\tfor (int j = 0; j &amp;lt; array2.length; j++) {\n\t\t\t\tSystem.out.println(array[i]+array[j]);\n\t\t\t}\n\t\t}\n\t}\n\n\n안에 2가지 for가 있다. O(n + n^2)로 표현가능하지만\n\nrule인 drop non dominants에 의하면 O(n^2)가 더 중요하므로 중요한것만 남겨 써야한다.\n\nSpace complexity\n\n\n\n공간 복잡도의 계산은 밑의 코드와 같이 계산할 수 있다.\n\n/*\n\t * 밖에서 booos의 관점에서는 밖에서 받아온 변수는 메모리에 포함이 안되기 때문에\n\t * booos불러 사용한다면 O(1)의 공간복잡도라고 할 수 있다.\n\t */\n\tpublic void booos(int [] n) {\n\t\tfor (int i = 0; i &amp;lt; n.length; i++) {\n\t\t\tSystem.out.println(&quot;boooo!!&quot;);\n\t\t}\n\t}\n\t\n\t\n\t/*\n\t * n개의 배열을 메소드안에서 생성하기 때문에 그만큼의 메모리가 필요하고\n\t * for문을 위한 i 변수의 매모리공간이 또 필요하기 때문에 O(n)의 공간 복잡도라고 할 수 있다.\n\t */\n\tpublic String[] makeArrayWithNum(int n) {\n\t\tString [] array = new String[n];\t//여기서 변수를 만들때 메모리를 소모\n\t\tfor (int i = 0; i &amp;lt; array.length; i++) {\t //iteration을 위한 i 변수에 의한 메모리 소모\n\t\t\tarray[i] = &quot;hi&quot;;\n\t\t}\n\t\treturn array;\n\t}\n\n\n더 좋은 프로그램을 만들기 위한 팁\n\n\n\nJavascript String의 length Property\n\n자바스크립트에서 String.length는 과연 얼마의 Big O notation을 가질까 한다면\n\n그것은 String의 글자 수에 달렸다고 말할 수 있지만\n\n자바스크립트 언어 자체에 내장된 length라는 것은 String 함수 자체가 가진 length를 그냥 읽어온 것이다.\n\nString함수를 작성하고 실행하여 String객체를 만들때 이미 length라는 property도 작성된다는 얘기.\n\n즉 함수가 아닌 String 함수내의 하나의 property이기 때문의 O(1)을 가진다.(즉, 그냥 변수 값을 가져오는것으로 생각 할 수 있다.)\n\n즉, 각 언어가 어떻게 동작하는지 알아서 기본적으로 내장된 기능들과 여러 api들의 big O notation을 파악할 수 있으면 훨씬 더 좋은 프로그램을 만들 수 있다는 것이다.\n\nBig O notation이 중요한 이유\n\n시간과 메모리 공간은 cost이고 이것을 측정하는 개념인 Big O notation이다.\n\n이것을 항상 염두해두며 최소한으로 줄일 줄 아는 엔지니어야 말로 회사의 황금과 같은 존재.\n\n따라서 쓰이는 개념은 아니지만 회사가 자주 물어보는 주제이며 engineer로서 항상 염두하고 해결하기 위해 노력해야한다.\n\n하지만 3가지의 좋은 프로그램의 조건을 모두 고려해야하므로 그 3가지를 잘 조절해서 가장 효율적인 코드를 짜내야한다.\n"
} ,
  
  {
    "title"    : "Markdown Syntax",
    "category" : "",
    "tags"     : " Markdown",
    "url"      : "/2020/02/20/Markdown-Syntax.html",
    "date"     : "February 20, 2020",
    "excerpt"  : "Markdown 문법 모음집이다.\n\n\n\n1단계 제목\n2단계 제목\n\n1단계 제목\n2단계 제목\n——-\n\n*목록1\n*목록2\n*목록3\n-이렇게 목록을 써도 됨\n-마이너스로 말이야\n\n\n  첫째입니다.\n  둘째입니다.\n  셋째입니다.\n  넷째입니다. 다섯째 아닙니다.\n  이게 다섯째입니다.\n  이건 여섯째.\n\n\n‘*’ 앞뒤 두번으로 굵게 쓰거나 ‘_’ 앞뒤 두번으로 두껍게 쓰거나\n\n‘’ 앞뒤 한번으로 *기울게 쓰면서 ‘’ 앞뒤 한번으로 _기울게 쓴다...",
  "content"  : "Markdown 문법 모음집이다.\n\n\n\n1단계 제목\n2단계 제목\n\n1단계 제목\n2단계 제목\n——-\n\n*목록1\n*목록2\n*목록3\n-이렇게 목록을 써도 됨\n-마이너스로 말이야\n\n\n  첫째입니다.\n  둘째입니다.\n  셋째입니다.\n  넷째입니다. 다섯째 아닙니다.\n  이게 다섯째입니다.\n  이건 여섯째.\n\n\n‘*’ 앞뒤 두번으로 굵게 쓰거나 ‘_’ 앞뒤 두번으로 두껍게 쓰거나\n\n‘’ 앞뒤 한번으로 *기울게 쓰면서 ‘’ 앞뒤 한번으로 _기울게 쓴다\n\n\n  인용문은\n  \n    ’&amp;gt;’로 이렇게 쓴다.\n  \n\n\n링크 다는 법\n[구글링크]https://www.google.com/\n\n[구글링크 주석형][google]\n[google]https://www.google.com/ “이것이 구글주석”\n\n여러가지 가로선\n\n\n\n\n\n————\n"
} ,
  
  {
    "title"    : "Sample post",
    "category" : "",
    "tags"     : " A Tag, Test, Lorem, Ipsum",
    "url"      : "/2019/06/30/sample-post.html",
    "date"     : "June 30, 2019",
    "excerpt"  : "Consectetur adipiscing elit. Donec a diam lectus. Sed sit amet ipsum mauris. Maecenas congue ligula ac quam viverra nec consectetur ante hendrerit. Donec et mollis dolor. \nPraesent et diam eget libero egestas mattis sit amet vitae augue. Nam tinci...",
  "content"  : "Consectetur adipiscing elit. Donec a diam lectus. Sed sit amet ipsum mauris. Maecenas congue ligula ac quam viverra nec consectetur ante hendrerit. Donec et mollis dolor. \nPraesent et diam eget libero egestas mattis sit amet vitae augue. Nam tincidunt congue enim, ut porta lorem lacinia consectetur. \n\nDonec ut libero sed arcu vehicula ultricies a non tortor. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean ut gravida lorem.\n\n\n  Consectetur adipiscing elit\n  Donec a diam lectus\n  Sed sit amet ipsum mauris\n\n\nUt turpis felis, pulvinar a semper sed, adipiscing id dolor. Pellentesque auctor nisi id magna consequat sagittis. Curabitur dapibus enim sit amet elit pharetra tincidunt feugiat nisl imperdiet. Ut convallis libero in urna ultrices accumsan. Donec sed odio eros. Donec viverra mi quis quam pulvinar at malesuada arcu rhoncus. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. In rutrum accumsan ultricies. Mauris vitae nisi at sem facilisis semper ac in est.\n\nNunc diam velit, adipiscing ut tristique vitae, sagittis vel odio. Maecenas convallis ullamcorper ultricies. Curabitur ornare, ligula semper consectetur sagittis, nisi diam iaculis velit, id fringilla sem nunc vel mi. Nam dictum, odio nec pretium volutpat, arcu ante placerat erat, non tristique elit urna et turpis. Quisque mi metus, ornare sit amet fermentum et, tincidunt et orci. Fusce eget orci a orci congue vestibulum.\n\n\n\nUt dolor diam, elementum et vestibulum eu, porttitor vel elit. Curabitur venenatis pulvinar tellus gravida ornare. Sed et erat faucibus nunc euismod ultricies ut id justo. Nullam cursus suscipit nisi, et ultrices justo sodales nec. Fusce venenatis facilisis lectus ac semper. Aliquam at massa ipsum. Quisque bibendum purus convallis nulla ultrices ultricies. Nullam aliquam, mi eu aliquam tincidunt, purus velit laoreet tortor, viverra pretium nisi quam vitae mi. Fusce vel volutpat elit. Nam sagittis nisi dui.\n\n\n  Suspendisse lectus leo, consectetur in tempor sit amet, placerat quis neque\n\n\nEtiam luctus porttitor lorem, sed suscipit est rutrum non. Curabitur lobortis nisl a enim congue semper. Aenean commodo ultrices imperdiet. Vestibulum ut justo vel sapien venenatis tincidunt.\n\nPhasellus eget dolor sit amet ipsum dapibus condimentum vitae quis lectus. Aliquam ut massa in turpis dapibus convallis. Praesent elit lacus, vestibulum at malesuada et, ornare et est. Ut augue nunc, sodales ut euismod non, adipiscing vitae orci. Mauris ut placerat justo. Mauris in ultricies enim. Quisque nec est eleifend nulla ultrices egestas quis ut quam. Donec sollicitudin lectus a mauris pulvinar id aliquam urna cursus. Cras quis ligula sem, vel elementum mi. Phasellus non ullamcorper urna.\n"
} ,
  
  {
    "title"    : "Color Post",
    "category" : "",
    "tags"     : " Test, Color, Markdown",
    "url"      : "/2019/05/18/color-post.html",
    "date"     : "May 18, 2019",
    "excerpt"  : "What a colorful post!\n\nThis is an idea that came from xukimseven/HardCandy-Jekyll \nlooking at this cheerful and colorful them, I wanted to enable something similar for mine.\n\nYou can go fork and star hers too! 😉\n\n\n\nHow does it work?\n\nBasically you...",
  "content"  : "What a colorful post!\n\nThis is an idea that came from xukimseven/HardCandy-Jekyll \nlooking at this cheerful and colorful them, I wanted to enable something similar for mine.\n\nYou can go fork and star hers too! 😉\n\n\n\nHow does it work?\n\nBasically you need to add just one thing, the color:\n\n---\nlayout: post\ntitle: Color Post\ncolor: brown\n---\n\n\nIt can either be a html color like brown (which look like red to me). Or with the rgb:\n\n---\nlayout: post\ntitle: Color Post\ncolor: rgb(165,42,42)\n---\n\n\nThe background used is lineart.png from xukimseven you can edit it in the config file. \nIf you want another one, put it in /assets/img as well.\n\n  ⚠️ It’s a bit hacking the css in the post.html\n\n"
} ,
  
  {
    "title"    : "Feature images",
    "category" : "",
    "tags"     : " Test, Lorem",
    "url"      : "/2014/11/29/feature-images.html",
    "date"     : "November 29, 2014",
    "excerpt"  : "This is an example of a post which includes a feature image specified in the front matter of the post. \nThe feature image spans the full-width of the page, and is shown with the title on permalink pages:\n\nfeature-img: &quot;assets/img/pexels/desk-messy...",
  "content"  : "This is an example of a post which includes a feature image specified in the front matter of the post. \nThe feature image spans the full-width of the page, and is shown with the title on permalink pages:\n\nfeature-img: &quot;assets/img/pexels/desk-messy.jpeg&quot;\n\n\n\n  \n    And now it is working\n  \n\n"
} ,
  
  {
    "title"    : "Markdown and HTML",
    "category" : "",
    "tags"     : " Test, Markdown",
    "url"      : "/2014/11/28/markdown-and-html.html",
    "date"     : "November 28, 2014",
    "excerpt"  : "Jekyll supports the use of Markdown with inline HTML tags which makes it easier to quickly write posts with Jekyll, without having to worry too much about text formatting. A sample of the formatting follows.\n\nTables have also been extended from Ma...",
  "content"  : "Jekyll supports the use of Markdown with inline HTML tags which makes it easier to quickly write posts with Jekyll, without having to worry too much about text formatting. A sample of the formatting follows.\n\nTables have also been extended from Markdown:\n\n\n  \n    \n      First Header\n      Second Header\n    \n  \n  \n    \n      Content Cell\n      Content Cell\n    \n    \n      Content Cell\n      Content Cell\n    \n  \n\n\nHere’s an example of an image, which is included using Markdown:\n\n\n\nHighlighting for code in Jekyll is done using Base16 or Rouge. This theme makes use of Rouge by default.\n\n// count to ten\nfor (var i = 1; i &amp;lt;= 10; i++) {\n    console.log(i);\n}\n\n// count to twenty\nvar j = 0;\nwhile (j &amp;lt; 20) {\n    j++;\n    console.log(j);\n}\n\nType on Strap uses KaTeX to display maths. Equations such as  can be displayed inline.\n\nAlternatively, they can be shown on a new line:\n\n\n"
} ,
  
  {
    "title"    : "What&#39;s your title",
    "category" : "",
    "tags"     : " Test, Lorem",
    "url"      : "/2014/11/27/whats-your-title.html",
    "date"     : "November 27, 2014",
    "excerpt"  : "This is an example of a post which includes a feature image that has a\ntext, where you don’t want to redisplay the title.\nWe cannot simply set the title to the empty string, as that would\nbreak pages that list this post, such as home and tags.\n\n",
  "content"  : "This is an example of a post which includes a feature image that has a\ntext, where you don’t want to redisplay the title.\nWe cannot simply set the title to the empty string, as that would\nbreak pages that list this post, such as home and tags.\n\n"
} ,
  
  {
    "title"    : "Markup: Syntax Highlighting",
    "category" : "",
    "tags"     : " code",
    "url"      : "/2014/08/08/Markup-Syntax-Highlighting.html",
    "date"     : "August 8, 2014",
    "excerpt"  : "From Michael’s Rose Minimal Mistakes.\nSyntax highlighting is a feature that displays source code, in different colors and fonts according to the category of terms. This feature facilitates writing in a structured language such as a programming lan...",
  "content"  : "From Michael’s Rose Minimal Mistakes.\nSyntax highlighting is a feature that displays source code, in different colors and fonts according to the category of terms. This feature facilitates writing in a structured language such as a programming language or a markup language as both structures and syntax errors are visually distinct. Highlighting does not affect the meaning of the text itself; it is intended only for human readers.\n\nGFM Code Blocks\n\nGitHub Flavored Markdown fenced code blocks are supported. To modify styling and highlight colors edit /_sass/syntax.scss.\n\n#container {\n  float: left;\n  margin: 0 -240px 0 0;\n  width: 100%;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n.highlight {\n  margin: 0;\n  padding: 1em;\n  font-family: $monospace;\n  font-size: $type-size-7;\n  line-height: 1.8;\n}\n\n\n&amp;lt;nav class=&quot;pagination&quot; role=&quot;navigation&quot;&amp;gt;\n  {% if page.previous %}\n    &amp;lt;a href=&quot;{{ site.url }}{{ page.previous.url }}&quot; class=&quot;btn&quot; title=&quot;{{ page.previous.title }}&quot;&amp;gt;Previous article&amp;lt;/a&amp;gt;\n  {% endif %}\n  {% if page.next %}\n    &amp;lt;a href=&quot;{{ site.url }}{{ page.next.url }}&quot; class=&quot;btn&quot; title=&quot;{{ page.next.title }}&quot;&amp;gt;Next article&amp;lt;/a&amp;gt;\n  {% endif %}\n&amp;lt;/nav&amp;gt;&amp;lt;!-- /.pagination --&amp;gt;\n\n\nmodule Jekyll\n  class TagIndex &amp;lt; Page\n    def initialize(site, base, dir, tag)\n      @site = site\n      @base = base\n      @dir = dir\n      @name = &#39;index.html&#39;\n      self.process(@name)\n      self.read_yaml(File.join(base, &#39;_layouts&#39;), &#39;tag_index.html&#39;)\n      self.data[&#39;tag&#39;] = tag\n      tag_title_prefix = site.config[&#39;tag_title_prefix&#39;] || &#39;Tagged: &#39;\n      tag_title_suffix = site.config[&#39;tag_title_suffix&#39;] || &#39;&amp;amp;#8211;&#39;\n      self.data[&#39;title&#39;] = &quot;#{tag_title_prefix}#{tag}&quot;\n      self.data[&#39;description&#39;] = &quot;An archive of posts tagged #{tag}.&quot;\n    end\n  end\nend\n\n\nCode Blocks in Lists\n\nIndentation matters. Be sure the indent of the code block aligns with the first non-space character after the list item marker (e.g., 1.). Usually this will mean indenting 3 spaces instead of 4.\n\n\n  Do step 1.\n  \n    Now do this:\n\n    def print_hi(name)\n  puts &quot;Hi, #{name}&quot;\nend\nprint_hi(&#39;Tom&#39;)\n#=&amp;gt; prints &#39;Hi, Tom&#39; to STDOUT.\n    \n  \n  Now you can do this.\n\n\nGitHub Gist Embed\n\nAn example of a Gist embed below.\n\n\n\nSource\n\n"
} ,
  
  {
    "title"    : "Generate a table of content",
    "category" : "",
    "tags"     : " toc.js, kramdown, Markdown, Customization",
    "url"      : "/2013/12/12/Generate-a-table-of-content.html",
    "date"     : "December 12, 2013",
    "excerpt"  : "Test article, get the source on github.\n\nUsing Kramdown GFM \n\n\n\n  Using Kramdown GFM     \n      Basic Usage\n    \n  \n  Using toc.js    \n      Customize with toc.js        \n          Use with this jekyll template\n        \n      \n      Basic Usage\n  ...",
  "content"  : "Test article, get the source on github.\n\nUsing Kramdown GFM \n\n\n\n  Using Kramdown GFM     \n      Basic Usage\n    \n  \n  Using toc.js    \n      Customize with toc.js        \n          Use with this jekyll template\n        \n      \n      Basic Usage\n      How it would look like\n    \n  \n\n\nBasic Usage\n\nYou need to put this at the beginning of the page where you want the table of content to be displayed\n\n* TOC\n{:toc}\n\n\nIt will then render the markdown and html titles (lines that begins with # or using the &amp;lt;h1&amp;gt;&amp;lt;/h1&amp;gt; tages)\n\nUsing toc.js\n\nDemo display of jekyll-table-of-contents by ghiculescu.\n\n\n\n\nCustomize with toc.js\n\ntoc.js stands for table of content, it is a js plugin that generates automatically a table of content of a post.\n\nUse with this jekyll template\n\nIf you want to customize the theme it is up to you, you can add the toc.js file into the asset &amp;gt; js and add it into the page.html layout with:\n\n&amp;lt;script src=&quot;/assets/js/toc.js&quot; &amp;gt;&amp;lt;/script&amp;gt;\n\nThen you can use it as it is said on the repository.\n\nBasic Usage\n\nThe script requires jQuery. First, reference toc.js in templates where you would like to add the table of content. Then, create an HTML element wherever you want your table of contents to appear:\n\n&amp;lt;div id=&quot;toc&quot;&amp;gt;&amp;lt;/div&amp;gt;\n\n\nThen you put your post with titles and all like:\n\n## Title\n## Mid title 1\nThis is text on page one\n## Mid title 2\nThis is text for page two\n### Sub title 2.a\nSome more text\n\n\nThen at the end of your post, you call the .toc() function using:\n\n&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;\n$(document).ready(function() {\n    $(&#39;#toc&#39;).toc();\n});\n&amp;lt;/script&amp;gt;\n\n\nHow it would look like\n\n\n\n\n\n\n\n\n"
} ,
  
  {
    "title"    : "Blogging with title",
    "category" : "",
    "tags"     : " Test, Ipsum, Markdown, Portfolio",
    "url"      : "/2013/11/18/blogging-with-title.html",
    "date"     : "November 18, 2013",
    "excerpt"  : "I am a BIG title\n\nThis is a very tiny tiny post with less than 250 letters.\n\nSearch should be working even for complicated escape symbols\nsed -i &#39;s/\\&quot;hostname\\&quot;\\:.*$/\\&quot;hostname\\&quot;\\: \\&quot;&#39;$IPADDR&#39;\\&quot;\\,/g&#39; open-falcon/agent/config/cfg.json\n\n",
  "content"  : "I am a BIG title\n\nThis is a very tiny tiny post with less than 250 letters.\n\nSearch should be working even for complicated escape symbols\nsed -i &#39;s/\\&quot;hostname\\&quot;\\:.*$/\\&quot;hostname\\&quot;\\: \\&quot;&#39;$IPADDR&#39;\\&quot;\\,/g&#39; open-falcon/agent/config/cfg.json\n\n"
} 
  
  ,
  
  {
  
  "title"    : "Ninja",
  "category" : "",
  "tags"     : " Lorem",
  "url"      : "/portfolio/ninja",
  "date"     : "April 8, 2014",
  "excerpt"  : "\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem qu...",
  "content"  : "\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?\n\n"
  
} ,
  
  {
  
  "title"    : "Creative",
  "category" : "",
  "tags"     : " Ipsum",
  "url"      : "/portfolio/safe",
  "date"     : "August 16, 2014",
  "excerpt"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia...",
  "content"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?\nUse this area of the page to describe your project. The icon above is part of a free icon set by Flat Icons. On their website, you can download their free set with 16 icons, or you can purchase the entire set with 146 icons for only $12!\n"
  
} ,
  
  {
  
  "title"    : "Circus",
  "category" : "",
  "tags"     : " Ipsum",
  "url"      : "/portfolio/circus",
  "date"     : "September 1, 2014",
  "excerpt"  : "\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem qu...",
  "content"  : "\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?\n\n"
  
} ,
  
  {
  
  "title"    : "Tower of Hanoi",
  "category" : "",
  "tags"     : " ",
  "url"      : "/portfolio/hanoi",
  "date"     : "September 1, 2014",
  "excerpt"  : "\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem qu...",
  "content"  : "\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?\n\n"
  
} ,
  
  {
  
  "title"    : "Tic tac toe",
  "category" : "",
  "tags"     : " ",
  "url"      : "/portfolio/tictactoe",
  "date"     : "September 1, 2014",
  "excerpt"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia...",
  "content"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?\n\n"
  
} ,
  
  {
  
  "title"    : "Cake",
  "category" : "",
  "tags"     : " Lorem, Ipsum, Portfolio",
  "url"      : "/portfolio/cake",
  "date"     : "September 27, 2015",
  "excerpt"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia...",
  "content"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?\nUse this area of the page to describe your project. The icon above is part of a free icon set by Flat Icons. On their website, you can download their free set with 16 icons, or you can purchase the entire set with 146 icons for only $12!\n"
  
} ,
  
  {
  
  "title"    : "Jekyll",
  "category" : "",
  "tags"     : " ",
  "url"      : "/portfolio/jekyllblog",
  "date"     : "May 26, 2017",
  "excerpt"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia...",
  "content"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?\n\n"
  
} ,
  
  {
  
  "title"    : "Lorem Ipsum",
  "category" : "",
  "tags"     : " ",
  "url"      : "/portfolio/submarine",
  "date"     : "September 3, 2017",
  "excerpt"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia...",
  "content"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?\nUse this area of the page to describe your project. The icon above is part of a free icon set by Flat Icons. On their website, you can download their free set with 16 icons, or you can purchase the entire set with 146 icons for only $12!\n\n"
  
} ,
  
  {
  
  "title"    : "Github",
  "category" : "",
  "tags"     : " Lorem, Portfolio",
  "url"      : "/portfolio/gitlecture",
  "date"     : "October 20, 2017",
  "excerpt"  : "\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem qu...",
  "content"  : "\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?\n\n"
  
} 
  
]
